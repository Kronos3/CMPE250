;****************************************************************
;EQUates
; Queue management record field offsets
IN_PTR      EQU   0
OUT_PTR     EQU   4
BUF_STRT    EQU   8
BUF_PAST    EQU   12
BUF_SIZE    EQU   16
NUM_ENQD    EQU   17
; Queue structure sizes
Q_BUF_SZ    EQU   4   ;Queue contents
Q_REC_SZ    EQU   18  ;Queue management record

; Initialize a queue structure with the
; following parameters
; R0: Pointer to the first address of the circular buffer
; R1: Pointer to the start of the queue structure
; R2: Size of the circular buffer pointed to by R0
; No output is generated/no registers are changed
; Uses R0-R2
InitQueue   PROC {R0-R2}
            PUSH {R0-R2}
            STR   R0,[R1,#IN_PTR]
            STR   R0,[R1,#OUT_PTR]
            STR   R0,[R1,#BUF_STRT]
            ADDS  R0,R0,R2
            STR   R0,[R1,#BUF_PAST]
            STRB  R2,[R1,#BUF_SIZE]
            MOVS  R0,#0
            STRB  R0,[R1,#NUM_ENQD]
            POP  {R0-R2}
            BX   LR
            ENDP

;If the queue (whose queue record structure’s address is in R1) is not full, enqueues the 
;character from R0 to the queue and reports success by returning with the C flag 
;cleared, (i.e., 0); otherwise only reports failure by returning with the C flag set, (i.e., 1). 
; Input:  R0:  Character to enqueue
;         R1:  Address of queue record structure
; Output:  PSR C flag:  Success(0) or Failure (1)
; Modify:  APSR
; All other registers remain unchanged on return
Enqueue     PROC {}
            PUSH {R2,R3}
            LDRB R2,[R1,#NUM_ENQD]
            LDRB R3,[R1,#BUF_SIZE]
            CMP  R2,R3  ; Check if the queue is full
            BGE  en_full
            STRB R0,[R1,#IN_PTR]; Put new element at memory location pointed by InPointer
            ; Increment NumberEnqueued
            LDRB R2,[R1,#NUM_ENQD] 
            ADDS R2,R2,#1
            STRB R2,[R1,#NUM_ENQD]

            ; Increment InPointer
            LDR  R2,[R1,#IN_PTR]
            ADDS R2,R2,#1
            LDR  R3,[R1,#BUF_PAST]
            CMP  R2,R3
            BLT  en_str  ; If (R1->in_ptr < R1->BUF_PAST) goto de_str
            ; IN_PTR is past the end of the queue
            ; We need to set it back to the start of the queue
            LDR  R2,[R1,#BUF_STRT]
en_str      STR  R2,[R1,#IN_PTR]
            ; Clear the carry flag  (No error occured)
            MRS  R2,APSR
            MOVS R3,#0x20
            LSLS R3,R3,#24
            BICS R2,R2,R3
            MSR  APSR,R2
            B    en_done ; Don't clear the APSR C-flag
en_full     ; Set the carry flag  (Error occured)
            MRS  R2,APSR
            MOVS R3,#0x20
            LSLS R3,R3,#24
            ORRS R2,R2,R3
            MSR  APSR,R2
en_done     POP  {R2,R3}
            BX   LR
            END

;If the queue (whose queue record structure’s address is in R1) is not empty, dequeues  
;a character from the queue to R0 and reports success by returning with the Cflag 
;cleared, (i.e., 0)
; otherwise only reports failure by returning with the Cflag set, (i.e., 1). 
; Input:  R1:  Address of queue record structure 
; Output: R0:  Character dequeued 
;         PSR C flag:  Success(0) or Failure (1)
; Modify: R0
; APSR 
; All other registers remain unchanged on return
Dequeue     PROC {R2,R3}
            PUSH {R2,R3}
            LDRB R2,[R1,#NUM_ENQD]
            CMP  R2,#0
            BLE  de_empty  ; No more items in the queue
            LDRB R0,[R1,#OUT_PTR] ; Get item at OUT_PTR
            ; Decrement number enqueued
            LDRB R2,[R1,#NUM_ENQD]
            SUBS R2,R2,#1
            STRB R2,[R1,#NUM_ENQD]

            ; Increment OutPointer
            LDRB R2,[R1,#OUT_PTR]
            ADDS R2,R2,#1
            LDR  R3,[R1,#BUF_PAST]
            CMP  R2,R3
            BLT  de_str  ; If (R1->out_ptr < R1->BUF_PAST) goto de_str
            ; OUT_PTR is past the end of the queue
            ; We need to set it back to the start of the queue
            LDR  R2,[R1,#BUF_STRT]
de_str      STR  R2,[R1,#OUT_PTR]
            ; Clear the carry flag (No error occured)
            MRS  R2,APSR
            MOVS R3,#0x20
            LSLS R3,R3,#24
            BICS R2,R2,R3
            MSR  APSR,R2
            B    de_done
de_empty    ; Set the carry flag (Error occured)
            MRS  R2,APSR
            MOVS R3,#0x20
            LSLS R3,R3,#24
            ORRS R2,R2,R3
            MSR  APSR,R2
de_done     POP  {R2,R3}
            BX   LR
            ENDP


; Print a number in hex
; Input parameter:
;   R0: number to print in hexadecimal (unsigned word value)
; Output parameter: (none)
PutNumHex   PROC {R0,R1}
RIGHT_NIBBLE_MASK EQU 0x0F
            PUSH {R0,R1,LR}
            ; There are 4 bytes to print
            MOVS R1,#0 ; Use R1 as an iterator
            RORS R0,R0,#24 ; Move the MSB to the LSB
            CMP  R1,#4
            BGE  pnh_done
            ; Print the most significant nibble
            LSRS R2,R1,#4
            ANDS R2,R2,#RIGHT_NIBBLE_MASK
            BL   PutDigHex ; Print this digit
            
            ; Print the least significant nibble
            MOVS R2,R1
            ANDS R2,R2,#RIGHT_NIBBLE_MASK
            BL   PutDigHex
            RORS R1,R1,#8 ; Move to the next byte
            ADDS R1,R1,#1 ; i++
pnh_done    POP  {R0,R1,PC}
            ENDP

; Prints to the terminal screen the decimal representation of the
; unsigned byte value in R0
; Input parameter:
;   R0:number to print in decimal (unsigned byte value)
;Output parameter: (none)
PutNumUB    PROC {R0}
BYTE_MASK   EQU  0xFF
            PUSH {R0,LR}
            ANDS R0,R0,#BYTE_MASK
            BL   PutNumU
            POP  {R0,PC}
            ENDP

; Print a single hex digit
; stored in R2
; Input parameter
PutDigHex   PROC {R0}
ASCII_LETTER EQU 10 ; Any values greater than or equal to this will be a letter A-F
ASCII_DIG_OFF EQU '0'
ASCII_LET_OFF EQU 'A'
            PUSH {R0,LR}
            CMP  R2,#ASCII_LETTER
            BGE  put_hex_letter
            ADDS R0,R2,#ASCII_DIG_OFF
            B    put_dig
put_hex_letter
            ADDS R0,R2,#ASCII_LET_OFF
put_dig     BL   PutChar
            POP  {R0,PC}
            ENDP

; Print a number in decimal using the ascii
; characters
; SUBROUTINES USED
;   - PutChar (Print each digit)
;   - DIVU
; PARAMS
;   INPUT R0: Number to print (unsigned word value)
;   OUTPUT  : NONE
PutNumU             PROC {R0-R2}
                    PUSH {R0-R2,LR}
printbase           EQU  10
asciioffset         EQU  '0'
                    ; put_num_u(U32 r0)
                    ; while (r0 != 0)
                    ;   (add r0 % 10 to stack)
                    ;   r0 /= 10
                    ; print the stack backwards
                    CMP R0,#0  ; Just print a '0'
                    BEQ numzero
                    
                    MOVS  R2,#0             ; Count the number of digits
numwhile            CMP   R0,#0             ; while (r0 != 0)
                    BEQ   numwhile2
                    MOVS  R1,#printbase     ; Always divide by the base
                    BL    DIVU              ; R0 = R0 / base; R0 % base
                    PUSH  {R1}              ; Need to print these digits backwards
                    ADDS  R2,R2,#1          ; r2++
                    B     numwhile
numwhile2           CMP   R2,#1             ; while (r2 >= 1)
                    BLT   numdone
                    POP   {R1}
                    MOVS  R0,R1
                    ADDS  R0,R0,#asciioffset ; Print the next character (ascii not just value)
                    SUBS  R2,R2,#1
                    BL    PutChar
                    B     numwhile2
numzero             MOVS  R0,#'0'
                    BL    PutChar
numdone             POP   {R0-R2,PC}
                    ENDP

; Calculate the quotient and remainder of
; two unsigned word values.
; SUBROUTINES: None
; PARAMS:
;   INPUT R0: dividend (unsigned word)
;   INPUT R1: divisor  (unsigned word)
;   OUTPUT R0: quotient (unsigned word)
;   OUTPUT R1: remainder (unsigned word)
DIVU        PROC {R0-R7}
            PUSH {LR}
            PUSH {R2-R7}
            CMP  R1,#0
            BEQ  DIVU_0     ; Don't try to divide by zero
LEFT_MASK   EQU  0x80 ; Used to get most significant bit of a byte
SHIFT32     EQU  31
            ; Compute N / D
            ; Use binary long division
            ; R = 0 (Use R2)
            ; Q = 0 (Use R3)
            ; for (i = 31; i >= 0; i--) {
            ;   R = R << 1
            ;   R |= (N & LEFT_MASK) >> 31
            ;   N = N << 1
            ;   if R >= D {
            ;       R = R - D
            ;       Q |= 1 << i
            ;   }
            ; }
            MOVS R2,#0       ; Init Remainder
            MOVS R3,#0       ; Init the Quotient
            MOVS R4,#SHIFT32 ; Init the iterator (i)
            MOVS R6,#1       ; Used for Q = Q | (1 << i)
DIV_FOR     CMP  R4,#0       ; if (i >= 0)
            BLT  DIVU_FINISH ; Finished loop
            LSLS R2,R2,#1    ; R = R << 1
            LSRS R5,R0,#SHIFT32   ; R5 = most significant bit in N
            MOVS R6,#1
            ANDS R5,R5,R6    ; R5 = (N & LEFT_MASK) >> 31
            ORRS R2,R2,R5    ; R |= (N & LEFT_MASK) >> 31
            LSLS R0,R0,#1    ; N = N << 1
            CMP  R2,R1       ; if (R >= D)
            BLO  DIV_ITER    ; continue;
            SUBS R2,R2,R1    ; R = R - D
            LSLS R6,R6,R4    ; R6 = 1 << i
            MOVS R5,R6
            ORRS R3,R3,R5    ; Q = Q | (1 << i)
DIV_ITER    SUBS R4,R4,#1    ; i--
            B    DIV_FOR     ; For loop
DIVU_FINISH MOVS R0,R3       ; Set the outputs
            MOVS R1,R2       ;
            ; Clear the carry flag
            MRS  R2,APSR
            MOVS R3,#0x20
            LSLS R3,R3,#24
            BICS R2,R2,R3
            MSR  APSR,R2
            B    DIVU_STOP
DIVU_0      MOVS R3,#1       ; Init R3 as 1
            ; Set the carry flag
            MRS  R2,APSR
            MOVS R3,#0x20
            LSLS R3,R3,#24
            ORRS R2,R2,R3
            MSR  APSR,R2
DIVU_STOP   POP  {R2-R7}
            POP  {PC}
            ENDP
