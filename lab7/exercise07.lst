


ARM Macro Assembler    Page 1 Program Title for Listing Header Goes Here


    1 00000000                 TTL              Program Title for Listing Heade
r Goes Here
    2 00000000         ;*******************************************************
                       *********
    3 00000000         ;Descriptive comment header goes here.
    4 00000000         ;Implements a circular buffer queue strucute 
    5 00000000         ;Name:  Andrei Tumbar
    6 00000000         ;Date:  10/07/20
    7 00000000         ;Class:  CMPE-250
    8 00000000         ;Section:  5, Tuesday, 11 AM
    9 00000000         ;-------------------------------------------------------
                       --------
   10 00000000         ;Keil Template for KL05
   11 00000000         ;R. W. Melton
   12 00000000         ;September 13, 2020
   13 00000000         ;*******************************************************
                       *********
   14 00000000         ;Assembler directives
   15 00000000                 THUMB
   17 00000000         ;*******************************************************
                       *********
   18 00000000         ;Include files
   19 00000000                 GET              MKL05Z4.s   ;Included by start.
                                                            s
   21 00000000         ;*******************************************************
                       *********
   22 00000000         ;EQUates
   23 00000000         ; UART0 Equates
   24 00000000         ;UART0 register addresses as well as bit field offsets a
                       nd masks
   25 00000000         ;from 'MKL05Z4.s' included by program template
   26 00000000         ;-------------------------------------------------------
                       --------
   27 00000000         ;UART0_BDH
   28 00000000         ; 0-> 7:LIN break detect IE (disabled)
   29 00000000         ; 0-> 6:RxD input active edge IE (disabled)
   30 00000000         ; 0-> 5:Stop bit number select (1)
   31 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)])
   32 00000000         ;UART0CLK is MCGFLLCLK
   33 00000000         ;MCGPLLCLK is 47972352 Hz ~=~ 48 MHz
   34 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   35 00000000         ;SBR = 47972352 / (9600 * 16) = 312.32 --> 312 = 0x138
   36 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
   37 00000000         ;-------------------------------------------------------
                       --------
   38 00000000         ;UART0_BDL
   39 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
   40 00000000         ;UART0CLK is MCGFLLCLK
   41 00000000         ;MCGPLLCLK is 47972352 Hz ~=~ 48 MHz
   42 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   43 00000000         ;SBR = 47972352 / (9600 * 16) = 312.32 --> 312 = 0x138
   44 00000000 00000038 
                       UART0_BDL_9600
                               EQU              0x38
   45 00000000         
   46 00000000         ;UART0_C1
   47 00000000         ;0-->7:LOOPS=loops select (normal)



ARM Macro Assembler    Page 2 Program Title for Listing Header Goes Here


   48 00000000         ;0-->6:DOZEEN=doze enable (disabled)
   49 00000000         ;0-->5:RSRC=receiver source select (internal--no effect 
                       LOOPS=0)
   50 00000000         ;0-->4:M=9- or 8-bit mode select
   51 00000000         ; (1 start, 8 data [lsb first], 1 stop)
   52 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
   53 00000000         ;0-->2:IDLE=idle line type select (idle begins after sta
                       rt bit)
   54 00000000         ;0-->1:PE=parity enable (disabled)
   55 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
   56 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
   57 00000000         ;-------------------------------------------------------
                       --------
   58 00000000         ;UART0_C2
   59 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
   60 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
   61 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
   62 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
   63 00000000         ;1-->3:TE=transmitter enable (enabled)
   64 00000000         ;1-->2:RE=receiver enable (enabled)
   65 00000000         ;0-->1:RWU=receiver wakeup control (normal)
   66 00000000         ;0-->0:SBK=send break (disabled, normal)
   67 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2
_RE_MASK)
   68 00000000         
   69 00000000         ;UART0_C3
   70 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
   71 00000000         ; 10th data bit for transmitter (not used M10=0)
   72 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
   73 00000000         ; 10th data bit for receiver (not used M10=0)
   74 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
   75 00000000         ; (no effect LOOPS=0)
   76 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
   77 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
   78 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
   79 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
   80 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
   81 00000000 00000000 
                       UART0_C3_NO_TXINV
                               EQU              0x00
   82 00000000         
   83 00000000         ;UART0_C4
   84 00000000         ; 0--> 7:MAEN1=match address mode enable 1 (disabled)
   85 00000000         ; 0--> 6:MAEN2=match address mode enable 2 (disabled)
   86 00000000         ; 0--> 5:M10=10-bit mode select (not selected)
   87 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
   88 00000000         ; = 1 + OSR for 3 <= OSR <= 31
   89 00000000         ; = 16 for 0 <= OSR <= 2 (invalid values)
   90 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
   91 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
   92 00000000         ;-------------------------------------------------------



ARM Macro Assembler    Page 3 Program Title for Listing Header Goes Here


                       --------
   93 00000000         ;UART0_C5
   94 00000000         ; 0--> 7:TDMAE=transmitter DMA enable (disabled)
   95 00000000         ; 0--> 6:Reserved; read-only; always 0
   96 00000000         ; 0--> 5:RDMAE=receiver full DMA enable (disabled)
   97 00000000         ;000-->4-2:Reserved; read-only; always 0
   98 00000000         ; 0--> 1:BOTHEDGE=both edge sampling (rising edge only)
   99 00000000         ; 0--> 0:RESYNCDIS=resynchronization disable (enabled)
  100 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  101 00000000         
  102 00000000         ;UART0_S1
  103 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
                       
  104 00000000         ;0-->6:TC=transmission complete flag; read-only
  105 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  106 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  107 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear
                       )
  108 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  109 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  110 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  115 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              (UART0_S1_IDLE_MASK :OR:  UART
0_S1_OR_MASK :OR:  UART0_S1_NF_MASK :OR:  UART0_S1_FE_MASK :OR:  UART0_S1_PF
_MASK)
  116 00000000         
  117 00000000         ;UART0_S2
  118 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  119 00000000         ; write 1 to clear
  120 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear
                       )
  121 00000000         ; write 1 to clear
  122 00000000         ;0-->5:(reserved); read-only; always 0
  123 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  124 00000000         ;0-->3:RWUID=receive wake-up idle detect
  125 00000000         ;0-->2:BRK13=break character generation length (10)
  126 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  127 00000000         ;0-->0:RAF=receiver active flag; read-only
  129 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              (UART0_S2_LBKDIF_MASK :OR: UART
0_S2_RXEDGIF_MASK)
  130 00000000         
  131 00000000         ;*******************************************************
                       *********
  132 00000000         ;EQUates
  133 00000000         ; Queue management record field offsets
  134 00000000 00000000 
                       IN_PTR  EQU              0
  135 00000000 00000004 
                       OUT_PTR EQU              4
  136 00000000 00000008 
                       BUF_STRT
                               EQU              8
  137 00000000 0000000C 
                       BUF_PAST



ARM Macro Assembler    Page 4 Program Title for Listing Header Goes Here


                               EQU              12
  138 00000000 00000010 
                       BUF_SIZE
                               EQU              16
  139 00000000 00000011 
                       NUM_ENQD
                               EQU              17
  140 00000000         ; Queue structure sizes
  141 00000000 00000004 
                       Q_BUF_SZ
                               EQU              4           ;Queue contents
  142 00000000 00000012 
                       Q_REC_SZ
                               EQU              18          ;Queue management r
                                                            ecord
  143 00000000         
  144 00000000         
  145 00000000                 MACRO
  146 00000000         $label  PUSH_STATUS      $RBUF, $R
  147 00000000                 LDRB             $RBUF,[$R,#NUM_ENQD]
  148 00000000                 PUSH             {$RBUF}
  149 00000000                 LDR              $RBUF,[$R,#OUT_PTR]
  150 00000000                 PUSH             {$RBUF}
  151 00000000                 LDR              $RBUF,[$R,#IN_PTR]
  152 00000000                 PUSH             {$RBUF}
  153 00000000                 MEND
  154 00000000         
  155 00000000                 MACRO
  156 00000000         $label  P                $string
  157 00000000                 PUSH             {R1}
  158 00000000                 LDR              R1,=$string
  159 00000000                 BL               printf
  160 00000000                 POP              {R1}
  161 00000000                 MEND
  162 00000000         
  163 00000000         ;*******************************************************
                       *********
  164 00000000         ;Program
  165 00000000         ;Linker requires Reset_Handler
  166 00000000                 AREA             MyCode,CODE,READONLY
  167 00000000                 ENTRY
  168 00000000                 EXPORT           Reset_Handler
  169 00000000                 IMPORT           Startup
  170 00000000         Reset_Handler
                               PROC             {}
  171 00000000         main
  172 00000000         ;-------------------------------------------------------
                       --------
  173 00000000         ;Mask interrupts
  174 00000000 B672            CPSID            I
  175 00000002         ;KL05 system startup with 48-MHz system clock
  176 00000002 F7FF FFFE       BL               Startup
  177 00000006 F7FF FFFE       BL               Init_UART0_Polling
  178 0000000A         ;-------------------------------------------------------
                       --------
  179 0000000A         ;>>>>> begin main program code <<<<<
  180 0000000A         ; Initialize a queue structure with
  181 0000000A         ; a 4-byte circular buffer
  182 0000000A 48EE            LDR              R0,=buffer



ARM Macro Assembler    Page 5 Program Title for Listing Header Goes Here


  183 0000000C 49EE            LDR              R1,=queue
  184 0000000E 2204            MOVS             R2,#Q_BUF_SZ
  185 00000010 F7FF FFFE       BL               InitQueue
  186 00000014         
  187 00000014         __9     P                newline
  157 00000014 B402            PUSH             {R1}
  158 00000016 49ED            LDR              R1,=newline
  159 00000018 F7FF FFFE       BL               printf
  160 0000001C BC02            POP              {R1}
  188 0000001E         
  189 0000001E         main_loop
  190 0000001E         __0     P                prompt      ; Print the prompt 
                                                            string
  157 0000001E B402            PUSH             {R1}
  158 00000020 49EB            LDR              R1,=prompt
  159 00000022 F7FF FFFE       BL               printf
  160 00000026 BC02            POP              {R1}
  191 00000028         ; Get input
  192 00000028 F7FF FFFE       BL               GetChar
  193 0000002C F7FF FFFE       BL               PutChar
  194 00000030         
  195 00000030         ; Print a newline and handle the inputed command
  196 00000030                 P                newline
  157 00000030 B402            PUSH             {R1}
  158 00000032 49E6            LDR              R1,=newline
  159 00000034 F7FF FFFE       BL               printf
  160 00000038 BC02            POP              {R1}
  197 0000003A F7FF FFFE       BL               HandleCommand
  198 0000003E         
  199 0000003E E7EE            B                main_loop
  200 00000040         
  201 00000040         ;>>>>>   end main program code <<<<<
  202 00000040         ;Stay here
  203 00000040 E7FE            B                .
  204 00000042                 ENDP
  205 00000042         ;>>>>> begin subroutine code <<<<<
  206 00000042         
  207 00000042         ; Handle a command input
  208 00000042         ; Subroutines used:
  209 00000042         ;   Dequene
  210 00000042         ;   Enqueue
  211 00000042         ;   printf
  212 00000042         ;   PutChar
  213 00000042         ; Input:
  214 00000042         ;   R0: input command (case insensitive)
  215 00000042         ;   R1: Pointer to queue structure
  216 00000042         ; Output (None)
  217 00000042         ; Modified Registers (None)
  218 00000042         HandleCommand
                               PROC             {R0-R12}
  219 00000042 B51F            PUSH             {R0-R4,LR}
  220 00000044 00000061 
                       AS_L_S  EQU              'a'
  221 00000044 0000007A 
                       AS_L_E  EQU              'z'
  222 00000044 00000041 
                       AS_U_S  EQU              'A'
  223 00000044 0000005A 
                       AS_U_E  EQU              'Z'



ARM Macro Assembler    Page 6 Program Title for Listing Header Goes Here


  224 00000044         
  225 00000044         ; Convert the character to upper-case
  226 00000044 2841            CMP              R0,#AS_U_S
  227 00000046 DB4A            BLT              invalid_char
  228 00000048 285A            CMP              R0,#AS_U_E
  229 0000004A DD01            BLE              do_cmd      ; Already in upperc
                                                            ase
  230 0000004C         ; Convert to upper case
  231 0000004C 3820            SUBS             R0,R0,#(AS_L_S - AS_U_S)
  232 0000004E E7FF            B                do_cmd
  233 00000050         
  234 00000050 2844    do_cmd  CMP              R0,#'D'
  235 00000052 D008            BEQ              do_deq
  236 00000054 2845            CMP              R0,#'E'
  237 00000056 D00C            BEQ              do_enq
  238 00000058 2848            CMP              R0,#'H'
  239 0000005A D03C            BEQ              do_help
  240 0000005C 2850            CMP              R0,#'P'
  241 0000005E D01A            BEQ              do_print
  242 00000060 2853            CMP              R0,#'S'
  243 00000062 D032            BEQ              do_status
  244 00000064 E03B            B                invalid_char
  245 00000066         
  246 00000066 F7FF FFFE 
                       do_deq  BL               Dequeue
  247 0000006A D245            BCS              handle_fail
  248 0000006C F7FF FFFE       BL               PutChar
  249 00000070 E048            B                print_status
  250 00000072         
  251 00000072         do_enq                               ; Print the enqueue
                                                             prompt
  252 00000072         __1     P                prompt_en
  157 00000072 B402            PUSH             {R1}
  158 00000074 49D7            LDR              R1,=prompt_en
  159 00000076 F7FF FFFE       BL               printf
  160 0000007A BC02            POP              {R1}
  253 0000007C         
  254 0000007C         ; Get the character and enqueue it
  255 0000007C F7FF FFFE       BL               GetChar
  256 00000080 F7FF FFFE       BL               PutChar
  257 00000084         __8     P                newline
  157 00000084 B402            PUSH             {R1}
  158 00000086 49D1            LDR              R1,=newline
  159 00000088 F7FF FFFE       BL               printf
  160 0000008C BC02            POP              {R1}
  258 0000008E         
  259 0000008E F7FF FFFE       BL               Enqueue
  260 00000092 D231            BCS              handle_fail
  261 00000094 E02A            B                handle_info
  262 00000096         
  263 00000096         do_print                             ; Print the content
                                                            s of the queue
  264 00000096 203E            MOVS             R0,#'>'
  265 00000098 F7FF FFFE       BL               PutChar
  266 0000009C 684A            LDR              R2,[R1,#OUT_PTR]
  267 0000009E 7C4B            LDRB             R3,[R1,#NUM_ENQD]
  268 000000A0 68CC            LDR              R4,[R1,#BUF_PAST]
  269 000000A2 421B    do_print_l
                               TST              R3,R3       ; While we have not



ARM Macro Assembler    Page 7 Program Title for Listing Header Goes Here


                                                             printed all of the
                                                             characters
  270 000000A4 D008            BEQ              do_print_b  ; break
  271 000000A6 7810            LDRB             R0,[R2,#0]  ; Print this charac
                                                            ter
  272 000000A8 F7FF FFFE       BL               PutChar
  273 000000AC 1C52            ADDS             R2,R2,#1    ; Increment the poi
                                                            nter
  274 000000AE 1E5B            SUBS             R3,R3,#1    ; Decrement the dow
                                                            n counter
  275 000000B0 42A2            CMP              R2,R4       ; Check if we need 
                                                            to circle back
  276 000000B2 DBF6            BLT              do_print_l
  277 000000B4 688A            LDR              R2,[R1,#BUF_STRT] ; Circle back
                                                             to the start of th
                                                            e buffer
  278 000000B6 E7F4            B                do_print_l
  279 000000B8 203C    do_print_b
                               MOVS             R0,#'<'
  280 000000BA F7FF FFFE       BL               PutChar
  281 000000BE                 P                newline
  157 000000BE B402            PUSH             {R1}
  158 000000C0 49C2            LDR              R1,=newline
  159 000000C2 F7FF FFFE       BL               printf
  160 000000C6 BC02            POP              {R1}
  282 000000C8 E025            B                end_handle
  283 000000CA         
  284 000000CA         do_status
  285 000000CA         __7     P                status_s
  157 000000CA B402            PUSH             {R1}
  158 000000CC 49C2            LDR              R1,=status_s
  159 000000CE F7FF FFFE       BL               printf
  160 000000D2 BC02            POP              {R1}
  286 000000D4 E016            B                print_status
  287 000000D6         
  288 000000D6 49C1    do_help LDR              R1,=help
  289 000000D8 F7FF FFFE       BL               printf
  290 000000DC E01B            B                end_handle
  291 000000DE         
  292 000000DE         invalid_char
  293 000000DE B402            PUSH             {R1}
  294 000000E0 B401            PUSH             {R0}
  295 000000E2 49BF            LDR              R1,=invalid_in
  296 000000E4 F7FF FFFE 
                       __6     BL               printf
  297 000000E8 BC02            POP              {R1}
  298 000000EA E014            B                end_handle
  299 000000EC         
  300 000000EC         handle_info
  301 000000EC         __4     P                success
  157 000000EC B402            PUSH             {R1}
  158 000000EE 49BD            LDR              R1,=success
  159 000000F0 F7FF FFFE       BL               printf
  160 000000F4 BC02            POP              {R1}
  302 000000F6 E005            B                print_status
  303 000000F8         handle_fail
  304 000000F8         __3     P                failure
  157 000000F8 B402            PUSH             {R1}
  158 000000FA 49BB            LDR              R1,=failure



ARM Macro Assembler    Page 8 Program Title for Listing Header Goes Here


  159 000000FC F7FF FFFE       BL               printf
  160 00000100 BC02            POP              {R1}
  305 00000102 E7FF            B                print_status
  306 00000104         print_status
  307 00000104         __2     PUSH_STATUS      R0,R1
  147 00000104 7C48            LDRB             R0,[R1,#NUM_ENQD]
  148 00000106 B401            PUSH             {R0}
  149 00000108 6848            LDR              R0,[R1,#OUT_PTR]
  150 0000010A B401            PUSH             {R0}
  151 0000010C 6808            LDR              R0,[R1,#IN_PTR]
  152 0000010E B401            PUSH             {R0}
  308 00000110 49B6            LDR              R1,=status
  309 00000112 F7FF FFFE 
                       __5     BL               printf
  310 00000116 BD1F    end_handle
                               POP              {R0-R4,PC}
  311 00000118                 ENDP
  312 00000118         
  313 00000118         ; This subroutine is a printf() clone with the following
                       
  314 00000118         ; formats defined:
  315 00000118         ;    %x: hex
  316 00000118         ;    %d: decimal
  317 00000118         ;    %s: string
  318 00000118         ;    %b: single byte decimal
  319 00000118         ;    %c: char
  320 00000118         ; Subroutines used:
  321 00000118         ;    PutChar
  322 00000118         ;    PutNumHex (%x)
  323 00000118         ;    PutNumU   (%d)
  324 00000118         ;    PutStringSB (%s)
  325 00000118         ;    PutNumUB (%b)
  326 00000118         ;    printf (recursive call on error)
  327 00000118         ; Input Registers:
  328 00000118         ;    R1: Pointer to the format string
  329 00000118         ;    N variables on the stack that correspond 
  330 00000118         ;    to arguments in the format string
  331 00000118         ; Output (None)
  332 00000118         ; Modified Registers (None)
  333 00000118         printf  PROC             {R0-R12}
  334 00000118         ; Because the stack is used to pass parameters to
  335 00000118         ; this subroutines. We can't modify the stack pointer
  336 00000118         ; before moving through the format string.
  337 00000118         ; Use the memory as a stack
  338 00000118 B420            PUSH             {R5}
  339 0000011A 4DB5            LDR              R5,=printf_static
  340 0000011C 6028            STR              R0,[R5,#0]
  341 0000011E 6069            STR              R1,[R5,#4]
  342 00000120 60AA            STR              R2,[R5,#8]
  343 00000122 60EB            STR              R3,[R5,#12]
  344 00000124 612C            STR              R4,[R5,#16]
  345 00000126 BC20            POP              {R5}
  346 00000128         
  347 00000128         ; Store the return pointer
  348 00000128 B500            PUSH             {LR}
  349 0000012A BC10            POP              {R4}
  350 0000012C         
  351 0000012C 780A    printf_loop
                               LDRB             R2,[R1,#0]



ARM Macro Assembler    Page 9 Program Title for Listing Header Goes Here


  352 0000012E 4212            TST              R2,R2
  353 00000130 D032            BEQ              printf_end  ;  End of string
  354 00000132 2A25            CMP              R2,#'%'     ; Format character
  355 00000134 D003            BEQ              printf_fmt
  356 00000136 0010            MOVS             R0,R2
  357 00000138 F7FF FFFE       BL               PutChar
  358 0000013C E02A            B                printf_continue
  359 0000013E 1C49    printf_fmt
                               ADDS             R1,R1,#1
  360 00000140 780A            LDRB             R2,[R1,#0]
  361 00000142 2A68            CMP              R2,#'h'     ; Print a hex strin
                                                            g
  362 00000144 D00F            BEQ              printf_h
  363 00000146 2A64            CMP              R2,#'d'     ; Print a decimal s
                                                            tring
  364 00000148 D011            BEQ              printf_d
  365 0000014A 2A73            CMP              R2,#'s'     ; Print a string
  366 0000014C D013            BEQ              printf_s
  367 0000014E 2A63            CMP              R2,#'c'
  368 00000150 D01C            BEQ              printf_c
  369 00000152 2A62            CMP              R2,#'b'     ; Print a single by
                                                            te
  370 00000154 D016            BEQ              printf_b
  371 00000156         ; INVALID FORMAT STRING
  372 00000156         ; Print the error string
  373 00000156 B420            PUSH             {R5}
  374 00000158 6869            LDR              R1,[R5,#4]
  375 0000015A BC20            POP              {R5}
  376 0000015C         
  377 0000015C B402            PUSH             {R1}
  378 0000015E 49A5            LDR              R1,=invalid
  379 00000160 F7FF FFFE       BL               printf
  380 00000164 E7FE            B                .           ; Invalid format st
                                                            ring (STOP)
  381 00000166         printf_h                             ; Print the current
                                                             number in R0
  382 00000166 BC01            POP              {R0}
  383 00000168 F7FF FFFE       BL               PutNumHex
  384 0000016C E012            B                printf_continue
  385 0000016E         printf_d                             ; Print the current
                                                             digit in R0
  386 0000016E BC01            POP              {R0}
  387 00000170 F7FF FFFE       BL               PutNumU
  388 00000174 E00E            B                printf_continue
  389 00000176         printf_s                             ; Print the string 
                                                            in R0
  390 00000176 BC01            POP              {R0}
  391 00000178 B402            PUSH             {R1}
  392 0000017A 2164            MOVS             R1,#100     ; Max string length
                                                             of 100
  393 0000017C F7FF FFFE       BL               PutStringSB
  394 00000180 BC02            POP              {R1}
  395 00000182 E007            B                printf_continue
  396 00000184         printf_b                             ; Print the single 
                                                            byte value in R0
  397 00000184 BC01            POP              {R0}
  398 00000186 F7FF FFFE       BL               PutNumUB
  399 0000018A E003            B                printf_continue
  400 0000018C         printf_c                             ; Print the single 



ARM Macro Assembler    Page 10 Program Title for Listing Header Goes Here


                                                            char value in R0
  401 0000018C BC01            POP              {R0}
  402 0000018E F7FF FFFE       BL               PutChar
  403 00000192 E7FF            B                printf_continue
  404 00000194 1C49    printf_continue
                               ADDS             R1,R1,#1
  405 00000196 E7C9            B                printf_loop
  406 00000198         printf_end                           ; Restore the link 
                                                            register
  407 00000198 B410            PUSH             {R4}        ; This will be POP'
                                                            ed to PC
  408 0000019A         
  409 0000019A         ; Restore registers from memory
  410 0000019A B420            PUSH             {R5}
  411 0000019C 4D94            LDR              R5,=printf_static
  412 0000019E 6828            LDR              R0,[R5,#0]
  413 000001A0 6869            LDR              R1,[R5,#4]
  414 000001A2 68AA            LDR              R2,[R5,#8]
  415 000001A4 68EB            LDR              R3,[R5,#12]
  416 000001A6 692C            LDR              R4,[R5,#16]
  417 000001A8 BC20            POP              {R5}
  418 000001AA         
  419 000001AA BD00            POP              {PC}
  420 000001AC                 ENDP
  421 000001AC         
  422 000001AC         ; Initialize a queue structure
  423 000001AC         ; Subroutines Used: (none)
  424 000001AC         ; Input:
  425 000001AC         ;   R0: Pointer to the first address of the circular buf
                       fer
  426 000001AC         ;   R1: Pointer to the start of the queue structure
  427 000001AC         ;   R2: Size of the circular buffer pointed to by R0
  428 000001AC         ; Output (None)
  429 000001AC         ; Modified Registers (None)
  430 000001AC         InitQueue
                               PROC             {R0-R12}
  431 000001AC B407            PUSH             {R0-R2}
  432 000001AE 6008            STR              R0,[R1,#IN_PTR]
  433 000001B0 6048            STR              R0,[R1,#OUT_PTR]
  434 000001B2 6088            STR              R0,[R1,#BUF_STRT]
  435 000001B4 1880            ADDS             R0,R0,R2
  436 000001B6 60C8            STR              R0,[R1,#BUF_PAST]
  437 000001B8 740A            STRB             R2,[R1,#BUF_SIZE]
  438 000001BA 2000            MOVS             R0,#0
  439 000001BC 7448            STRB             R0,[R1,#NUM_ENQD]
  440 000001BE BC07            POP              {R0-R2}
  441 000001C0 4770            BX               LR
  442 000001C2                 ENDP
  443 000001C2         
  444 000001C2         ; Emplace a character into the queue structure.
  445 000001C2         ; If the queue is already full, indicate failure
  446 000001C2         ; by setting the C flag in the APSR. A cleared C flag
  447 000001C2         ; indicates success.
  448 000001C2         ; Subroutes used: (none)
  449 000001C2         ; Input:  R0:  Character to enqueue
  450 000001C2         ;         R1:  Address of queue record structure
  451 000001C2         ; Output:  PSR C flag:  Success(0) or Failure (1)
  452 000001C2         ; Modify:  APSR
  453 000001C2         ; All other registers remain unchanged on return



ARM Macro Assembler    Page 11 Program Title for Listing Header Goes Here


  454 000001C2         Enqueue PROC             {R0-R12}
  455 000001C2 B40C            PUSH             {R2,R3}
  456 000001C4 7C4A            LDRB             R2,[R1,#NUM_ENQD]
  457 000001C6 7C0B            LDRB             R3,[R1,#BUF_SIZE]
  458 000001C8 429A            CMP              R2,R3       ; Check if the queu
                                                            e is full
  459 000001CA DA11            BGE              en_full
  460 000001CC 680B            LDR              R3,[R1,#IN_PTR]
  461 000001CE 7018            STRB             R0,[R3,#0]  ; Put new element a
                                                            t memory location p
                                                            ointed by InPointer
                                                            
  462 000001D0         ; Increment NumberEnqueued
  463 000001D0 1C52            ADDS             R2,R2,#1
  464 000001D2 744A            STRB             R2,[R1,#NUM_ENQD]
  465 000001D4         
  466 000001D4         ; Increment InPointer
  467 000001D4 1C5B            ADDS             R3,R3,#1
  468 000001D6 68CA            LDR              R2,[R1,#BUF_PAST]
  469 000001D8 4293            CMP              R3,R2
  470 000001DA DB00            BLT              en_str      ; If (R1->in_ptr < 
                                                            R1->BUF_PAST) goto 
                                                            en_str
  471 000001DC         ; IN_PTR is past the end of the queue
  472 000001DC         ; We need to set it back to the start of the queue
  473 000001DC 688B            LDR              R3,[R1,#BUF_STRT]
  474 000001DE 600B    en_str  STR              R3,[R1,#IN_PTR]
  475 000001E0         ; Clear the carry flag  (No error occured)
  476 000001E0 F3EF 8200       MRS              R2,APSR
  477 000001E4 2320            MOVS             R3,#0x20
  478 000001E6 061B            LSLS             R3,R3,#24
  479 000001E8 439A            BICS             R2,R2,R3
  480 000001EA F382 8800       MSR              APSR,R2
  481 000001EE E006            B                en_done     ; Don't clear the A
                                                            PSR C-flag
  482 000001F0         en_full                              ; Set the carry fla
                                                            g  (Error occured)
  483 000001F0 F3EF 8200       MRS              R2,APSR
  484 000001F4 2320            MOVS             R3,#0x20
  485 000001F6 061B            LSLS             R3,R3,#24
  486 000001F8 431A            ORRS             R2,R2,R3
  487 000001FA F382 8800       MSR              APSR,R2
  488 000001FE BC0C    en_done POP              {R2,R3}
  489 00000200 4770            BX               LR
  490 00000202                 ENDP
  491 00000202         
  492 00000202         ; Remove the next item from the queue structure.
  493 00000202         ; If the queue is already empty, indicate failure by
  494 00000202         ; setting the C flag in the APSR. A cleared C flag
  495 00000202         ; indicates success.
  496 00000202         ; Subroutines used: (none)
  497 00000202         ; Input:  R1:  Address of queue record structure 
  498 00000202         ; Output: R0:  Character dequeued 
  499 00000202         ;         PSR C flag:  Success(0) or Failure (1)
  500 00000202         ; Modify: R0
  501 00000202         ; APSR 
  502 00000202         ; All other registers remain unchanged on return
  503 00000202         Dequeue PROC             {R1-R12}
  504 00000202 B41C            PUSH             {R2-R4}



ARM Macro Assembler    Page 12 Program Title for Listing Header Goes Here


  505 00000204 7C4A            LDRB             R2,[R1,#NUM_ENQD] 
                                                            ; R2 = NUM_ENQ
  506 00000206 684B            LDR              R3,[R1,#OUT_PTR] ; R3 = OUT_PTR
                                                            
  507 00000208 2A00            CMP              R2,#0
  508 0000020A DD10            BLE              de_empty    ; No more items in 
                                                            the queue
  509 0000020C 7818            LDRB             R0,[R3,#0]  ; Get item at OUT_P
                                                            TR
  510 0000020E         ; Decrement number enqueued
  511 0000020E 1E52            SUBS             R2,R2,#1
  512 00000210 744A            STRB             R2,[R1,#NUM_ENQD]
  513 00000212         
  514 00000212         ; Increment OutPointer
  515 00000212 1C5B            ADDS             R3,R3,#1
  516 00000214 68CC            LDR              R4,[R1,#BUF_PAST]
  517 00000216 42A3            CMP              R3,R4
  518 00000218 DB00            BLT              de_str      ; If (R1->out_ptr <
                                                             R1->BUF_PAST) goto
                                                             de_str
  519 0000021A         ; OUT_PTR is past the end of the queue
  520 0000021A         ; We need to set it back to the start of the queue
  521 0000021A 688B            LDR              R3,[R1,#BUF_STRT]
  522 0000021C 604B    de_str  STR              R3,[R1,#OUT_PTR]
  523 0000021E         ; Clear the carry flag (No error occured)
  524 0000021E F3EF 8200       MRS              R2,APSR
  525 00000222 2320            MOVS             R3,#0x20
  526 00000224 061B            LSLS             R3,R3,#24
  527 00000226 439A            BICS             R2,R2,R3
  528 00000228 F382 8800       MSR              APSR,R2
  529 0000022C E006            B                de_done
  530 0000022E         de_empty                             ; Set the carry fla
                                                            g (Error occured)
  531 0000022E F3EF 8200       MRS              R2,APSR
  532 00000232 2320            MOVS             R3,#0x20
  533 00000234 061B            LSLS             R3,R3,#24
  534 00000236 431A            ORRS             R2,R2,R3
  535 00000238 F382 8800       MSR              APSR,R2
  536 0000023C BC1C    de_done POP              {R2-R4}
  537 0000023E 4770            BX               LR
  538 00000240                 ENDP
  539 00000240         
  540 00000240         
  541 00000240         ; Print a 32-bit number in hex
  542 00000240         ; Subroutines used:
  543 00000240         ;   PutDigHex
  544 00000240         ; Input parameter:
  545 00000240         ;   R0: number to print in hexadecimal (unsigned word va
                       lue)
  546 00000240         ; Output parameter: (none)
  547 00000240         PutNumHex
                               PROC             {R0-R12}
  548 00000240 0000000F 
                       RIGHT_NIBBLE_MASK
                               EQU              0x0F
  549 00000240 B51F            PUSH             {R0-R4,LR}
  550 00000242         ; There are 4 bytes to print
  551 00000242 2100            MOVS             R1,#0       ; Use R1 as an iter
                                                            ator



ARM Macro Assembler    Page 13 Program Title for Listing Header Goes Here


  552 00000244 2318            MOVS             R3,#24
  553 00000246 240F            MOVS             R4,#RIGHT_NIBBLE_MASK
  554 00000248 41D8            RORS             R0,R0,R3    ; Move the MSB to t
                                                            he LSB
  555 0000024A 2904    pnh_loop
                               CMP              R1,#4
  556 0000024C DA0A            BGE              pnh_done
  557 0000024E         ; Print the most significant nibble
  558 0000024E 0902            LSRS             R2,R0,#4
  559 00000250 4022            ANDS             R2,R2,R4
  560 00000252 F7FF FFFE       BL               PutDigHex   ; Print this digit
  561 00000256         ; Print the least significant nibble
  562 00000256 0002            MOVS             R2,R0
  563 00000258 4022            ANDS             R2,R2,R4
  564 0000025A F7FF FFFE       BL               PutDigHex
  565 0000025E 41D8            RORS             R0,R0,R3    ; Move to the next 
                                                            byte
  566 00000260 1C49            ADDS             R1,R1,#1    ; i++
  567 00000262 E7F2            B                pnh_loop
  568 00000264 BD1F    pnh_done
                               POP              {R0-R4,PC}
  569 00000266                 ENDP
  570 00000266         
  571 00000266         ; Print a single hex digit
  572 00000266         ; stored in R2
  573 00000266         ; Subroutines used:
  574 00000266         ;   PutChar
  575 00000266         ; Input parameter:
  576 00000266         ;   R2 Hex digit to print
  577 00000266         PutDigHex
                               PROC             {R0-R12}
  578 00000266 0000000A 
                       ASCII_LETTER
                               EQU              10          ; Any values greate
                                                            r than or equal to 
                                                            this will be a lett
                                                            er A-F
  579 00000266 00000030 
                       ASCII_DIG_OFF
                               EQU              '0'
  580 00000266 00000039 
                       ASCII_DIG_LAST
                               EQU              '9'
  581 00000266 00000007 
                       ASCII_LET_OFF
                               EQU              ('A' - '0' - 10)
  582 00000266 B50D            PUSH             {R0,R2,R3,LR}
  583 00000268 23FF            MOVS             R3,#0xFF
  584 0000026A 401A            ANDS             R2,R2,R3
  585 0000026C 3230            ADDS             R2,#ASCII_DIG_OFF
  586 0000026E 2A39            CMP              R2,#ASCII_DIG_LAST
  587 00000270 DB00            BLT              put_dig
  588 00000272 1DD2            ADDS             R2,R2,#ASCII_LET_OFF
  589 00000274 0010    put_dig MOVS             R0,R2
  590 00000276 F7FF FFFE       BL               PutChar
  591 0000027A BD0D            POP              {R0,R2,R3,PC}
  592 0000027C                 ENDP
  593 0000027C         
  594 0000027C         ; Prints to the terminal screen the decimal representati



ARM Macro Assembler    Page 14 Program Title for Listing Header Goes Here


                       on of the
  595 0000027C         ; unsigned byte value in R0
  596 0000027C         ; Subroutines Used:
  597 0000027C         ;  PutNumU
  598 0000027C         ; Input parameter:
  599 0000027C         ;   R0:number to print in decimal (unsigned byte value)
  600 0000027C         ;Output parameter: (none)
  601 0000027C         PutNumUB
                               PROC             {R0-R12}
  602 0000027C B503            PUSH             {R0,R1,LR}
  603 0000027E 21FF            MOVS             R1,#BYTE_MASK
  604 00000280 4008            ANDS             R0,R0,R1
  605 00000282 F7FF FFFE       BL               PutNumU
  606 00000286 BD03            POP              {R0,R1,PC}
  607 00000288                 ENDP
  608 00000288         
  609 00000288         ; Print a number in decimal using the ascii
  610 00000288         ; characters
  611 00000288         ; SUBROUTINES USED
  612 00000288         ;   - PutChar (Print each digit)
  613 00000288         ;   - DIVU
  614 00000288         ; PARAMS
  615 00000288         ;   INPUT R0: Number to print (unsigned word value)
  616 00000288         ;   OUTPUT  : NONE
  617 00000288         PutNumU PROC             {R0-R12}
  618 00000288 B507            PUSH             {R0-R2,LR}
  619 0000028A 0000000A 
                       printbase
                               EQU              10
  620 0000028A 00000030 
                       asciioffset
                               EQU              '0'
  621 0000028A         ; put_num_u(U32 r0)
  622 0000028A         ; while (r0 != 0)
  623 0000028A         ;   (add r0 % 10 to stack)
  624 0000028A         ;   r0 /= 10
  625 0000028A         ; print the stack backwards
  626 0000028A 2800            CMP              R0,#0       ; Just print a '0'
  627 0000028C D011            BEQ              numzero
  628 0000028E         
  629 0000028E 2200            MOVS             R2,#0       ; Count the number 
                                                            of digits
  630 00000290 2800    numwhile
                               CMP              R0,#0       ; while (r0 != 0)
  631 00000292 D005            BEQ              numwhile2
  632 00000294 210A            MOVS             R1,#printbase ; Always divide b
                                                            y the base
  633 00000296 F7FF FFFE       BL               DIVU        ; R0 = R0 / base; R
                                                            0 % base
  634 0000029A B402            PUSH             {R1}        ; Need to print the
                                                            se digits backwards
                                                            
  635 0000029C 1C52            ADDS             R2,R2,#1    ; r2++
  636 0000029E E7F7            B                numwhile
  637 000002A0 2A01    numwhile2
                               CMP              R2,#1       ; while (r2 >= 1)
  638 000002A2 DB09            BLT              numdone
  639 000002A4 BC02            POP              {R1}
  640 000002A6 0008            MOVS             R0,R1



ARM Macro Assembler    Page 15 Program Title for Listing Header Goes Here


  641 000002A8 3030            ADDS             R0,R0,#asciioffset ; Print the 
                                                            next character (asc
                                                            ii not just value)
  642 000002AA 1E52            SUBS             R2,R2,#1
  643 000002AC F7FF FFFE       BL               PutChar
  644 000002B0 E7F6            B                numwhile2
  645 000002B2 2030    numzero MOVS             R0,#'0'
  646 000002B4 F7FF FFFE       BL               PutChar
  647 000002B8 BD07    numdone POP              {R0-R2,PC}
  648 000002BA                 ENDP
  649 000002BA         
  650 000002BA         ; Calculate the quotient and remainder of
  651 000002BA         ; two unsigned word values.
  652 000002BA         ; SUBROUTINES: None
  653 000002BA         ; PARAMS:
  654 000002BA         ;   INPUT R0: dividend (unsigned word)
  655 000002BA         ;   INPUT R1: divisor  (unsigned word)
  656 000002BA         ;   OUTPUT R0: quotient (unsigned word)
  657 000002BA         ;   OUTPUT R1: remainder (unsigned word)
  658 000002BA         DIVU    PROC             {R2-R12}
  659 000002BA B500            PUSH             {LR}
  660 000002BC B4FC            PUSH             {R2-R7}
  661 000002BE 2900            CMP              R1,#0
  662 000002C0 D01D            BEQ              DIVU_0      ; Don't try to divi
                                                            de by zero
  663 000002C2 00000080 
                       LEFT_MASK
                               EQU              0x80        ; Used to get most 
                                                            significant bit of 
                                                            a byte
  664 000002C2 0000001F 
                       SHIFT32 EQU              31
  665 000002C2         ; Compute N / D
  666 000002C2         ; Use binary long division
  667 000002C2         ; R = 0 (Use R2)
  668 000002C2         ; Q = 0 (Use R3)
  669 000002C2         ; for (i = 31; i >= 0; i--) {
  670 000002C2         ;   R = R << 1
  671 000002C2         ;   R |= (N & LEFT_MASK) >> 31
  672 000002C2         ;   N = N << 1
  673 000002C2         ;   if R >= D {
  674 000002C2         ;       R = R - D
  675 000002C2         ;       Q |= 1 << i
  676 000002C2         ;   }
  677 000002C2         ; }
  678 000002C2 2200            MOVS             R2,#0       ; Init Remainder
  679 000002C4 2300            MOVS             R3,#0       ; Init the Quotient
                                                            
  680 000002C6 241F            MOVS             R4,#SHIFT32 ; Init the iterator
                                                             (i)
  681 000002C8 2601            MOVS             R6,#1       ; Used for Q = Q | 
                                                            (1 << i)
  682 000002CA 2C00    DIV_FOR CMP              R4,#0       ; if (i >= 0)
  683 000002CC DB0D            BLT              DIVU_FINISH ; Finished loop
  684 000002CE 0052            LSLS             R2,R2,#1    ; R = R << 1
  685 000002D0 0FC5            LSRS             R5,R0,#SHIFT32 ; R5 = most sign
                                                            ificant bit in N
  686 000002D2 2601            MOVS             R6,#1
  687 000002D4 4035            ANDS             R5,R5,R6    ; R5 = (N & LEFT_MA



ARM Macro Assembler    Page 16 Program Title for Listing Header Goes Here


                                                            SK) >> 31
  688 000002D6 432A            ORRS             R2,R2,R5    ; R |= (N & LEFT_MA
                                                            SK) >> 31
  689 000002D8 0040            LSLS             R0,R0,#1    ; N = N << 1
  690 000002DA 428A            CMP              R2,R1       ; if (R >= D)
  691 000002DC D303            BLO              DIV_ITER    ; continue;
  692 000002DE 1A52            SUBS             R2,R2,R1    ; R = R - D
  693 000002E0 40A6            LSLS             R6,R6,R4    ; R6 = 1 << i
  694 000002E2 0035            MOVS             R5,R6
  695 000002E4 432B            ORRS             R3,R3,R5    ; Q = Q | (1 << i)
  696 000002E6 1E64    DIV_ITER
                               SUBS             R4,R4,#1    ; i--
  697 000002E8 E7EF            B                DIV_FOR     ; For loop
  698 000002EA 0018    DIVU_FINISH
                               MOVS             R0,R3       ; Set the outputs
  699 000002EC 0011            MOVS             R1,R2       ;
  700 000002EE         ; Clear the carry flag
  701 000002EE F3EF 8200       MRS              R2,APSR
  702 000002F2 2320            MOVS             R3,#0x20
  703 000002F4 061B            LSLS             R3,R3,#24
  704 000002F6 439A            BICS             R2,R2,R3
  705 000002F8 F382 8800       MSR              APSR,R2
  706 000002FC E007            B                DIVU_STOP
  707 000002FE 2301    DIVU_0  MOVS             R3,#1       ; Init R3 as 1
  708 00000300         ; Set the carry flag
  709 00000300 F3EF 8200       MRS              R2,APSR
  710 00000304 2320            MOVS             R3,#0x20
  711 00000306 061B            LSLS             R3,R3,#24
  712 00000308 431A            ORRS             R2,R2,R3
  713 0000030A F382 8800       MSR              APSR,R2
  714 0000030E BCFC    DIVU_STOP
                               POP              {R2-R7}
  715 00000310 BD00            POP              {PC}
  716 00000312                 ENDP
  717 00000312         
  718 00000312         
  719 00000312         ; PutChar will print a character to the terminal
  720 00000312         ; Subroutines used: (none)
  721 00000312         ; Input: R0 (character to print)
  722 00000312         ; Output; None
  723 00000312         ; Register modification list: R1-R3
  724 00000312         PutChar PROC             {R0-R12}
  725 00000312 B40E            PUSH             {R1-R3}
  726 00000314         
  727 00000314         ; Wait until last character has been sent
  728 00000314         ;Set Z if TDRE=0
  729 00000314 493C            LDR              R1,=UART0_BASE
  730 00000316 2280            MOVS             R2,#UART0_S1_TDRE_MASK
  731 00000318 790B    putchar_l
                               LDRB             R3,[R1,#UART0_S1_OFFSET]
  732 0000031A 421A            TST              R2,R3
  733 0000031C D0FC            BEQ              putchar_l
  734 0000031E         
  735 0000031E         ; Write the character to the terminal
  736 0000031E 71C8            STRB             R0,[R1,#UART0_D_OFFSET]
  737 00000320         
  738 00000320 BC0E            POP              {R1-R3}
  739 00000322 4770            BX               LR
  740 00000324                 ENDP



ARM Macro Assembler    Page 17 Program Title for Listing Header Goes Here


  741 00000324         
  742 00000324         ; GetChar will real a character from the terminal
  743 00000324         ; Subroutines used: (none)
  744 00000324         ; Input: None
  745 00000324         ; Output; R0 (character read from terminal)
  746 00000324         ; Register modification list: R1-R3
  747 00000324         GetChar PROC             {R1-R12}
  748 00000324 B40E            PUSH             {R1-R3}
  749 00000326         
  750 00000326         ; Wait until a character is ready
  751 00000326         ;Set Z if RDRF=0
  752 00000326 4938            LDR              R1,=UART0_BASE
  753 00000328 2220            MOVS             R2,#UART0_S1_RDRF_MASK
  754 0000032A 790B    getchar_l
                               LDRB             R3,[R1,#UART0_S1_OFFSET]
  755 0000032C 421A            TST              R2,R3
  756 0000032E D0FC            BEQ              getchar_l
  757 00000330         
  758 00000330         ; Read the value from the data register
  759 00000330 79C8            LDRB             R0,[R1,#UART0_D_OFFSET]
  760 00000332         
  761 00000332 BC0E            POP              {R1-R3}
  762 00000334 4770            BX               LR
  763 00000336                 ENDP
  764 00000336         
  765 00000336         ; Print a NULL terminated string
  766 00000336         ; SUBROUTINES USED
  767 00000336         ;   - PutChar (Print each character)
  768 00000336         ; PARAMS
  769 00000336         ;   INPUT R0: pointer to the target string (word address
                       )
  770 00000336         ;   INPUT R1: size of the string buffer so that to not o
                       verflow (unsigned word value)
  771 00000336         ;   OUTPUT  : NONE
  772 00000336         PutStringSB
                               PROC             {R0-R12}
  773 00000336 B51F            PUSH             {R0-R4,LR}
  774 00000338         ; put_string_sb(char* r0, size_t r1)
  775 00000338         ;   iter = r0
  776 00000338         ;   while (*iter && iter - r0 < r1 - 1)
  777 00000338         ;       printf("%c", *iter)
  778 00000338         ;       iter++
  779 00000338 0002            MOVS             R2,R0       ; iter = r0
  780 0000033A 0004            MOVS             R4,R0       ; start = r0 (r0 ne
                                                            eds to be used for 
                                                            printing)
  781 0000033C 1E49            SUBS             R1,R1,#1
  782 0000033E         
  783 0000033E 7813    putwhile
                               LDRB             R3,[R2,#0]  ; r3 = *iter
  784 00000340 2B00            CMP              R3,#0       ; if (!*r3) break
  785 00000342 D007            BEQ              putdone
  786 00000344 1B13            SUBS             R3,R2,R4
  787 00000346 428B            CMP              R3,R1       ; if (iter - start 
                                                            >= r1 - 1) break
  788 00000348 DA04            BGE              putdone
  789 0000034A 7810            LDRB             R0,[R2,#0]  ; r0 = *iter
  790 0000034C F7FF FFFE       BL               PutChar     ; printf("%c", *ite
                                                            r);



ARM Macro Assembler    Page 18 Program Title for Listing Header Goes Here


  791 00000350 1C52            ADDS             R2,R2,#1    ; iter++
  792 00000352 E7F4            B                putwhile
  793 00000354 BD1F    putdone POP              {R0-R4,PC}
  794 00000356                 ENDP
  795 00000356         
  796 00000356         ; Initialize the UART0 serial polling with
  797 00000356         ; 8 databits, no parity, one stop bit
  798 00000356         ; Subroutines used: (none)
  799 00000356         ; Input: None
  800 00000356         ; Output: None
  801 00000356         ; Register modification: R0-R2
  802 00000356         Init_UART0_Polling
                               PROC             {R3-R12}
  803 00000356 B407            PUSH             {R0-R2}
  804 00000358         ; Select/configure UART0 sources
  805 00000358 04000000 
                       SIM_SOPT2_UART0SRC_MCGFLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
  806 00000358         ; Set the UART0 clock to 48 MHz
  807 00000358 482C            LDR              R0,=SIM_SOPT2
  808 0000035A 492D            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  809 0000035C 6802            LDR              R2,[R0,#0]  ;current SIM_SOPT2v
                                                            alue
  810 0000035E 438A            BICS             R2,R2,R1    ;only UART0SRCbits 
                                                            cleared
  811 00000360 492C            LDR              R1,=SIM_SOPT2_UART0SRC_MCGFLLCL
K
  812 00000362 430A            ORRS             R2,R2,R1    ;only UART0 bits ch
                                                            anged
  813 00000364 6002            STR              R2,[R0,#0]  ;update SIM_SOPT2
  814 00000366         
  815 00000366         ; Set SIM_SOPT5 for UART0 External
  816 00000366 00010005 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR: S
IM_SOPT5_UART0RXSRC_MASK :OR: SIM_SOPT5_UART0TXSRC_MASK)
  817 00000366 482C            LDR              R0,=SIM_SOPT5
  818 00000368 492C            LDR              R1,=SIM_SOPT5_UART0_EXTERN_MASK
_CLEAR
  819 0000036A 6802            LDR              R2,[R0,#0]  ;current SIM_SOPT5v
                                                            alue
  820 0000036C 438A            BICS             R2,R2,R1    ;only UART0 bits cl
                                                            eared
  821 0000036E 6002            STR              R2,[R0,#0]  ;update SIM_SOPT5
  822 00000370         
  823 00000370         ; Enable clocks for UART0 and Port B
  824 00000370         ; Enable UART0 clocks
  825 00000370 482B            LDR              R0,=SIM_SCGC4
  826 00000372 492C            LDR              R1,=SIM_SCGC4_UART0_MASK
  827 00000374 6802            LDR              R2,[R0,#0]  ;current SIM_SCGC4v
                                                            alue
  828 00000376 430A            ORRS             R2,R2,R1    ;only UART0bit set
  829 00000378 6002            STR              R2,[R0,#0]  ;update SIM_SCGC4
  830 0000037A         
  831 0000037A         ; Set SIM_CGC5 for Port B Clock Enabled
  832 0000037A 482B            LDR              R0,=SIM_SCGC5
  833 0000037C 4929            LDR              R1,=SIM_SCGC5_PORTB_MASK
  834 0000037E 6802            LDR              R2,[R0,#0]  ;current SIM_SCGC5v
                                                            alue



ARM Macro Assembler    Page 19 Program Title for Listing Header Goes Here


  835 00000380 430A            ORRS             R2,R2,R1    ;only PORTBbit set
  836 00000382 6002            STR              R2,[R0,#0]  ;update SIM_SCGC5
  837 00000384         
  838 00000384         ; Select Port B mux pins to connect to UART0
  839 00000384 01000200 
                       PORT_PCR_SET_PTB2_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR: PORT_PC
R_MUX_SELECT_2_MASK)
  840 00000384 01000200 
                       PORT_PCR_SET_PTB1_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR: PORT_PC
R_MUX_SELECT_2_MASK)
  841 00000384         
  842 00000384 4829            LDR              R0,=PORTB_PCR2
  843 00000386 492A            LDR              R1,=PORT_PCR_SET_PTB2_UART0_RX
  844 00000388 6001            STR              R1,[R0,#0]  ;Port B pin 2 conne
                                                            cts to UART0 Rx
  845 0000038A 482A            LDR              R0,=PORTB_PCR1
  846 0000038C 4928            LDR              R1,=PORT_PCR_SET_PTB1_UART0_TX
  847 0000038E 6001            STR              R1,[R0,#0]  ;Port B pin 1 conne
                                                            cts to UART0 Tx
  848 00000390         
  849 00000390         ; Configure UART0 (register initialization)
  850 00000390         ; Load base addr for UART0
  851 00000390 481D            LDR              R0,=UART0_BASE
  852 00000392         
  853 00000392         ; Disable UART0
  854 00000392         
  855 00000392         
  856 00000392 210C            MOVS             R1,#UART0_C2_T_R
  857 00000394 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  858 00000396 438A            BICS             R2,R2,R1
  859 00000398 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  860 0000039A         
  861 0000039A         ; Set UART0 baud rate?BDH before BDL
  862 0000039A 2101            MOVS             R1,#UART0_BDH_9600
  863 0000039C 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  864 0000039E 2138            MOVS             R1,#UART0_BDL_9600
  865 000003A0 7041            STRB             R1,[R0,#UART0_BDL_OFFSET]
  866 000003A2         
  867 000003A2         ; Set UART0 character format for serial bit stream and c
                       lear flags
  868 000003A2 2100            MOVS             R1,#UART0_C1_8N1
  869 000003A4 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  870 000003A6 2100            MOVS             R1,#UART0_C3_NO_TXINV
  871 000003A8 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  872 000003AA 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  873 000003AC 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  874 000003AE 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  875 000003B0 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  876 000003B2 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  877 000003B4 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  878 000003B6 21C0            MOVS             R1,#UART0_S2_NO_RXINV_BRK10_NO_
LBKDETECT_CLEAR_FLAGS
  879 000003B8 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  880 000003BA         
  881 000003BA         ; Enable UART0
  882 000003BA 210C            MOVS             R1,#UART0_C2_T_R
  883 000003BC 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]



ARM Macro Assembler    Page 20 Program Title for Listing Header Goes Here


  884 000003BE         
  885 000003BE BC07            POP              {R0-R2}
  886 000003C0 4770            BX               LR
  887 000003C2                 ENDP
  888 000003C2         
  889 000003C2         ;>>>>>   end subroutine code <<<<<
  890 000003C2 00 00           ALIGN
  891 000003C4         ;*******************************************************
                       *********
  892 000003C4         ;Vector Table Mapped to Address 0 at Reset
  893 000003C4         ;Linker requires __Vectors to be exported
  894 000003C4 00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              4006A000 
              40048004 
              0C000000 
              04000000 
              40048010 
              00010005 
              40048034 
              00000400 
              40048038 
              4004A008 
              01000200 
              4004A004         AREA             RESET, DATA, READONLY
  895 00000000                 EXPORT           __Vectors
  896 00000000                 EXPORT           __Vectors_End
  897 00000000                 EXPORT           __Vectors_Size
  898 00000000                 IMPORT           __initial_sp
  899 00000000                 IMPORT           Dummy_Handler
  900 00000000                 IMPORT           HardFault_Handler
  901 00000000         __Vectors
  902 00000000         ;ARM core vectors
  903 00000000 00000000        DCD              __initial_sp ;00:end of stack
  904 00000004 00000000        DCD              Reset_Handler ;01:reset vector
  905 00000008 00000000        DCD              Dummy_Handler ;02:NMI
  906 0000000C 00000000        DCD              HardFault_Handler 
                                                            ;03:hard fault
  907 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
  908 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
  909 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)
  910 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
  911 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
  912 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)



ARM Macro Assembler    Page 21 Program Title for Listing Header Goes Here


  913 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
  914 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (super
                                                            visor call)
  915 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
  916 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)
  917 00000038 00000000        DCD              Dummy_Handler ;14:PendSV (Penda
                                                            bleSrvReq)
  918 0000003C         ;   pendable request 
  919 0000003C         ;   for system service)
  920 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (syst
                                                            em tick timer)
  921 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0
                                                             transfer 
  922 00000044         ;   complete/error
  923 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1
                                                             transfer
  924 00000048         ;   complete/error
  925 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2
                                                             transfer
  926 0000004C         ;   complete/error
  927 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3
                                                             transfer
  928 00000050         ;   complete/error
  929 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
  930 00000054 00000000        DCD              Dummy_Handler ;21:FTFA command 
                                                            complete/
  931 00000058         ;   read collision
  932 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage d
                                                            etect;
  933 0000005C         ;   low-voltage warning
  934 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage w
                                                            akeup
  935 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
  936 00000064 00000000        DCD              Dummy_Handler ;25:(reserved)
  937 00000068 00000000        DCD              Dummy_Handler ;26:SPI0
  938 0000006C 00000000        DCD              Dummy_Handler ;27:(reserved)
  939 00000070 00000000        DCD              Dummy_Handler ;28:UART0 (status
                                                            ; error)
  940 00000074 00000000        DCD              Dummy_Handler ;29:(reserved)
  941 00000078 00000000        DCD              Dummy_Handler ;30:(reserved)
  942 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
  943 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
  944 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
  945 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
  946 0000008C 00000000        DCD              Dummy_Handler ;35:(reserved)
  947 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
  948 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
                                                            
  949 00000098 00000000        DCD              Dummy_Handler ;38:PIT
  950 0000009C 00000000        DCD              Dummy_Handler ;39:(reserved)
  951 000000A0 00000000        DCD              Dummy_Handler ;40:(reserved)
  952 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
  953 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
  954 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
  955 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
  956 000000B4 00000000        DCD              Dummy_Handler ;45:(reserved)
  957 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA
  958 000000BC 00000000        DCD              Dummy_Handler ;47:PORTB
  959 000000C0         __Vectors_End



ARM Macro Assembler    Page 22 Program Title for Listing Header Goes Here


  960 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors
  961 000000C0                 ALIGN
  962 000000C0         ;*******************************************************
                       *********
  963 000000C0         ;Constants
  964 000000C0                 AREA             MyConst,DATA,READONLY
  965 00000000         ;>>>>> begin constants here <<<<<
  966 00000000 54 79 70 
              65 20 61 
              20 71 75 
              65 75 65 
              20 63 6F 
              6D 6D 61 
              6E 64 20 
              28 44 2C 
              45 2C 48 
              2C 50 2C 
              53 29 3A 
              00       prompt  DCB              "Type a queue command (D,E,H,P,
S):\0"
  967 00000022 43 68 61 
              72 61 63 
              74 65 72 
              20 74 6F 
              20 65 6E 
              71 75 65 
              75 65 3A 
              00       prompt_en
                               DCB              "Character to enqueue:\0"
  968 00000038 3A 09 49 
              6E 3D 30 
              78 25 68 
              20 20 4F 
              75 74 3D 
              30 78 25 
              68 20 20 
              4E 75 6D 
              3D 25 62 
              0D 0A 00 status  DCB              ":\tIn=0x%x  Out=0x%x  Num=%b\r
\n\0"
  969 00000056 53 74 61 
              74 75 73 
              00       status_s
                               DCB              "Status\0"
  970 0000005D 53 75 63 
              63 65 73 
              73 00    success DCB              "Success\0"
  971 00000065 46 61 69 
              6C 75 72 
              65 00    failure DCB              "Failure\0"
  972 0000006D 0D 0A 00 
                       newline DCB              "\r\n\0"
  973 00000070 0D 0A 0D 
              0A 49 6E 
              76 61 6C 
              69 64 20 
              66 6F 72 



ARM Macro Assembler    Page 23 Program Title for Listing Header Goes Here


              6D 61 74 
              20 73 74 
              72 69 6E 
              67 20 27 
              25 73 27 
              0D 0A 00 invalid DCB              "\r\n\r\nInvalid format string 
'%s'\r\n\0"
  974 00000091 49 6E 76 
              61 6C 69 
              64 20 63 
              6F 6D 6D 
              61 6E 64 
              20 27 25 
              63 27 0D 
              0A 00    invalid_in
                               DCB              "Invalid command '%c'\r\n\0"
  975 000000A8 44 20 28 
              64 65 71 
              75 65 75 
              65 29 2C 
              20 45 20 
              28 65 6E 
              71 75 65 
              75 65 29 
              2C 20 48 
              20 28 68 
              65 6C 70 
              29 2C 20 
              50 20 28 
              70 72 69 
              6E 74 29 
              2C 20 53 
              20 28 73 
              74 61 74 
              75 73 29 
              0D 0A 00 help    DCB              "D (dequeue), E (enqueue), H (h
elp), P (print), S (status)\r\n\0"
  976 000000E4 54 65 73 
              74 20 73 
              74 72 69 
              6E 67 20 
              25 6A 64 
              73 6F 6B 
              61 00    test_invalid_printf
                               DCB              "Test string %jdsoka\0" ; Just 
                                                            used to test the pr
                                                            intf() function
  977 000000F8         ;>>>>>   end constants here <<<<<
  978 000000F8                 ALIGN
  979 000000F8         ;*******************************************************
                       *********
  980 000000F8         ;Variables
  981 000000F8                 AREA             MyData,DATA,READWRITE
  982 00000000         ;>>>>> begin variables here <<<<<
  983 00000000 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 24 Program Title for Listing Header Goes Here


              00 00 00 queue   SPACE            Q_REC_SZ
  984 00000012 00 00           ALIGN
  985 00000014 00 00 00 
              00       buffer  SPACE            Q_BUF_SZ
  986 00000018                 ALIGN
  987 00000018 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    printf_static
                               SPACE            20          ; Internal memory u
                                                            sed by printf
  988 0000002C         ;>>>>>   end variables here <<<<<
  989 0000002C                 ALIGN
  990 0000002C                 END
Command Line: --debug --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --
depend=.\objects\exercise07.d -o.\objects\exercise07.o -I"C:\Users\Andrei Tumba
r\AppData\Local\Arm\Packs\Keil\Kinetis_KLxx_DFP\1.14.0\Device\Include" -IC:\Kei
l_v5\ARM\CMSIS\Include --predefine="__EVAL SETA 1" --predefine="__UVISION_VERSI
ON SETA 531" --predefine="MKL05Z32xxx4 SETA 1" --list=.\listings\exercise07.lst
 Exercise07.s
