


ARM Macro Assembler    Page 1 Program Title for Listing Header Goes Here


    1 00000000                 TTL              Program Title for Listing Heade
r Goes Here
    2 00000000         ;*******************************************************
                       *********
    3 00000000         ;Descriptive comment header goes here.
    4 00000000         ;Add perform arithmetic on n-word unsigned integers
    5 00000000         ;Name:  Andrei Tumbar
    6 00000000         ;Date:  10/18/20
    7 00000000         ;Class:  CMPE-250
    8 00000000         ;Section:  5, Tuesday, 11 AM
    9 00000000         ;-------------------------------------------------------
                       --------
   10 00000000         ;Keil Template for KL05
   11 00000000         ;R. W. Melton
   12 00000000         ;September 13, 2020
   13 00000000         ;*******************************************************
                       *********
   14 00000000         ;Assembler directives
   15 00000000                 THUMB
   17 00000000         ;*******************************************************
                       *********
   18 00000000         ;Include files
   19 00000000                 GET              MKL05Z4.s   ;Included by start.
                                                            s
   21 00000000         ;*******************************************************
                       *********
   22 00000000         ;EQUates
   23 00000000         ; UART0 Equates
   24 00000000         ;UART0 register addresses as well as bit field offsets a
                       nd masks
   25 00000000         ;from 'MKL05Z4.s' included by program template
   26 00000000         ;-------------------------------------------------------
                       --------
   27 00000000         ;UART0_BDH
   28 00000000         ; 0-> 7:LIN break detect IE (disabled)
   29 00000000         ; 0-> 6:RxD input active edge IE (disabled)
   30 00000000         ; 0-> 5:Stop bit number select (1)
   31 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)])
   32 00000000         ;UART0CLK is MCGFLLCLK
   33 00000000         ;MCGPLLCLK is 47972352 Hz ~=~ 48 MHz
   34 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   35 00000000         ;SBR = 47972352 / (9600 * 16) = 312.32 --> 312 = 0x138
   36 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
   37 00000000         ;-------------------------------------------------------
                       --------
   38 00000000         ;UART0_BDL
   39 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
   40 00000000         ;UART0CLK is MCGFLLCLK
   41 00000000         ;MCGPLLCLK is 47972352 Hz ~=~ 48 MHz
   42 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   43 00000000         ;SBR = 47972352 / (9600 * 16) = 312.32 --> 312 = 0x138
   44 00000000 00000038 
                       UART0_BDL_9600
                               EQU              0x38
   45 00000000         
   46 00000000         ;UART0_C1
   47 00000000         ;0-->7:LOOPS=loops select (normal)



ARM Macro Assembler    Page 2 Program Title for Listing Header Goes Here


   48 00000000         ;0-->6:DOZEEN=doze enable (disabled)
   49 00000000         ;0-->5:RSRC=receiver source select (internal--no effect 
                       LOOPS=0)
   50 00000000         ;0-->4:M=9- or 8-bit mode select
   51 00000000         ; (1 start, 8 data [lsb first], 1 stop)
   52 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
   53 00000000         ;0-->2:IDLE=idle line type select (idle begins after sta
                       rt bit)
   54 00000000         ;0-->1:PE=parity enable (disabled)
   55 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
   56 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
   57 00000000         ;-------------------------------------------------------
                       --------
   58 00000000         ;UART0_C2
   59 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
   60 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
   61 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
   62 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
   63 00000000         ;1-->3:TE=transmitter enable (enabled)
   64 00000000         ;1-->2:RE=receiver enable (enabled)
   65 00000000         ;0-->1:RWU=receiver wakeup control (normal)
   66 00000000         ;0-->0:SBK=send break (disabled, normal)
   67 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2
_RE_MASK)
   68 00000000         
   69 00000000         ;UART0_C3
   70 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
   71 00000000         ; 10th data bit for transmitter (not used M10=0)
   72 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
   73 00000000         ; 10th data bit for receiver (not used M10=0)
   74 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
   75 00000000         ; (no effect LOOPS=0)
   76 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
   77 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
   78 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
   79 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
   80 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
   81 00000000 00000000 
                       UART0_C3_NO_TXINV
                               EQU              0x00
   82 00000000         
   83 00000000         ;UART0_C4
   84 00000000         ; 0--> 7:MAEN1=match address mode enable 1 (disabled)
   85 00000000         ; 0--> 6:MAEN2=match address mode enable 2 (disabled)
   86 00000000         ; 0--> 5:M10=10-bit mode select (not selected)
   87 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
   88 00000000         ; = 1 + OSR for 3 <= OSR <= 31
   89 00000000         ; = 16 for 0 <= OSR <= 2 (invalid values)
   90 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
   91 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
   92 00000000         ;-------------------------------------------------------



ARM Macro Assembler    Page 3 Program Title for Listing Header Goes Here


                       --------
   93 00000000         ;UART0_C5
   94 00000000         ; 0--> 7:TDMAE=transmitter DMA enable (disabled)
   95 00000000         ; 0--> 6:Reserved; read-only; always 0
   96 00000000         ; 0--> 5:RDMAE=receiver full DMA enable (disabled)
   97 00000000         ;000-->4-2:Reserved; read-only; always 0
   98 00000000         ; 0--> 1:BOTHEDGE=both edge sampling (rising edge only)
   99 00000000         ; 0--> 0:RESYNCDIS=resynchronization disable (enabled)
  100 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  101 00000000         
  102 00000000         ;UART0_S1
  103 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
                       
  104 00000000         ;0-->6:TC=transmission complete flag; read-only
  105 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  106 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  107 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear
                       )
  108 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  109 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  110 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  115 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              (UART0_S1_IDLE_MASK :OR:  UART
0_S1_OR_MASK :OR:  UART0_S1_NF_MASK :OR:  UART0_S1_FE_MASK :OR:  UART0_S1_PF
_MASK)
  116 00000000         
  117 00000000         ;UART0_S2
  118 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  119 00000000         ; write 1 to clear
  120 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear
                       )
  121 00000000         ; write 1 to clear
  122 00000000         ;0-->5:(reserved); read-only; always 0
  123 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  124 00000000         ;0-->3:RWUID=receive wake-up idle detect
  125 00000000         ;0-->2:BRK13=break character generation length (10)
  126 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  127 00000000         ;0-->0:RAF=receiver active flag; read-only
  129 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              (UART0_S2_LBKDIF_MASK :OR: UART
0_S2_RXEDGIF_MASK)
  130 00000000         
  131 00000000         ;*******************************************************
                       *********
  132 00000000                 MACRO
  133 00000000         $label  P                $string
  134 00000000                 PUSH             {R1}
  135 00000000                 LDR              R1,=$string
  136 00000000                 BL               printf
  137 00000000                 POP              {R1}
  138 00000000                 MEND
  139 00000000         
  140 00000000         ;Program
  141 00000000         ;Linker requires Reset_Handler
  142 00000000                 AREA             MyCode,CODE,READONLY



ARM Macro Assembler    Page 4 Program Title for Listing Header Goes Here


  143 00000000                 ENTRY
  144 00000000                 EXPORT           Reset_Handler
  145 00000000                 IMPORT           Startup
  146 00000000         Reset_Handler
                               PROC             {}
  147 00000000         main
  148 00000000         ;-------------------------------------------------------
                       --------
  149 00000000         ;Mask interrupts
  150 00000000 B672            CPSID            I
  151 00000002         ;KL05 system startup with 48-MHz system clock
  152 00000002 F7FF FFFE       BL               Startup
  153 00000006 F7FF FFFE       BL               Init_UART0_Polling
  154 0000000A         ;-------------------------------------------------------
                       --------
  155 0000000A         ;>>>>> begin main program code <<<<<
  156 0000000A 00000004 
                       WORD_COUNT
                               EQU              4
  157 0000000A         prompt_start
  158 0000000A         __1     P                newline
  134 0000000A B402            PUSH             {R1}
  135 0000000C 49F6            LDR              R1,=newline
  136 0000000E F7FF FFFE       BL               printf
  137 00000012 BC02            POP              {R1}
  159 00000014         __2     P                prompt_1
  134 00000014 B402            PUSH             {R1}
  135 00000016 49F5            LDR              R1,=prompt_1
  136 00000018 F7FF FFFE       BL               printf
  137 0000001C BC02            POP              {R1}
  160 0000001E         
  161 0000001E         ; Get the first number
  162 0000001E 48F4    prompt_fir
                               LDR              R0,=number_1
  163 00000020 2104            MOVS             R1,#WORD_COUNT
  164 00000022 F7FF FFFE       BL               GetHexMulti
  165 00000026 D224            BCS              invalid_input_1
  166 00000028         
  167 00000028         __5     P                prompt_2
  134 00000028 B402            PUSH             {R1}
  135 0000002A 49F2            LDR              R1,=prompt_2
  136 0000002C F7FF FFFE       BL               printf
  137 00000030 BC02            POP              {R1}
  168 00000032         
  169 00000032         ; Get the second number
  170 00000032 48F1    prompt_sec
                               LDR              R0,=number_2
  171 00000034 2104            MOVS             R1,#WORD_COUNT
  172 00000036 F7FF FFFE       BL               GetHexMulti
  173 0000003A D220            BCS              invalid_input_2
  174 0000003C         
  175 0000003C         ; Add the numbers and print them
  176 0000003C 48EF            LDR              R0,=result
  177 0000003E 49EC            LDR              R1,=number_1
  178 00000040 4AED            LDR              R2,=number_2
  179 00000042 2304            MOVS             R3,#WORD_COUNT
  180 00000044         
  181 00000044 F7FF FFFE       BL               AddIntMultiU
  182 00000048 D208            BCS              add_overflow



ARM Macro Assembler    Page 5 Program Title for Listing Header Goes Here


  183 0000004A         
  184 0000004A         __6     P                sum
  134 0000004A B402            PUSH             {R1}
  135 0000004C 49EC            LDR              R1,=sum
  136 0000004E F7FF FFFE       BL               printf
  137 00000052 BC02            POP              {R1}
  185 00000054 2104            MOVS             R1,#WORD_COUNT
  186 00000056 F7FF FFFE       BL               PutNumHexMulti
  187 0000005A E7D6            B                prompt_start
  188 0000005C         
  189 0000005C         add_overflow
  190 0000005C         __7     P                sum
  134 0000005C B402            PUSH             {R1}
  135 0000005E 49E8            LDR              R1,=sum
  136 00000060 F7FF FFFE       BL               printf
  137 00000064 BC02            POP              {R1}
  191 00000066         __8     P                overflow
  134 00000066 B402            PUSH             {R1}
  135 00000068 49E6            LDR              R1,=overflow
  136 0000006A F7FF FFFE       BL               printf
  137 0000006E BC02            POP              {R1}
  192 00000070 E7CB            B                prompt_start
  193 00000072         
  194 00000072         invalid_input_1
  195 00000072         __3     P                prompt_e
  134 00000072 B402            PUSH             {R1}
  135 00000074 49E4            LDR              R1,=prompt_e
  136 00000076 F7FF FFFE       BL               printf
  137 0000007A BC02            POP              {R1}
  196 0000007C E7CF            B                prompt_fir
  197 0000007E         invalid_input_2
  198 0000007E         __4     P                prompt_e
  134 0000007E B402            PUSH             {R1}
  135 00000080 49E1            LDR              R1,=prompt_e
  136 00000082 F7FF FFFE       BL               printf
  137 00000086 BC02            POP              {R1}
  199 00000088 E7D3            B                prompt_sec
  200 0000008A         ;>>>>>   end main program code <<<<<
  201 0000008A         ;Stay here
  202 0000008A E7FE            B                .
  203 0000008C                 ENDP
  204 0000008C         
  205 0000008C         ; Add two arbitarily sized unsigned integers
  206 0000008C         ; Input params:
  207 0000008C         ;    R1: n-word augend address
  208 0000008C         ;    R2: n-word addend address
  209 0000008C         ;    R3: n number of words in addend and augend
  210 0000008C         ; Output params:
  211 0000008C         ;    R0: n-word sum address
  212 0000008C         ;    C: 0 success, 1 failure (overflow)
  213 0000008C         ; Subroutines: None
  214 0000008C         AddIntMultiU
                               PROC             {R1-R12}
  215 0000008C B47F            PUSH             {R0-R6}
  216 0000008E         ; Use R3 as a down counter of words
  217 0000008E         ; Use R4 and R5 as temporary storage for
  218 0000008E         ; adding single words
  219 0000008E         
  220 0000008E         ; We first need to clear the C-flag



ARM Macro Assembler    Page 6 Program Title for Listing Header Goes Here


  221 0000008E B40C            PUSH             {R2,R3}
  222 00000090 F3EF 8200       MRS              R2,APSR
  223 00000094 2320            MOVS             R3,#0x20
  224 00000096 061B            LSLS             R3,R3,#24
  225 00000098 439A            BICS             R2,R2,R3
  226 0000009A F382 8800       MSR              APSR,R2
  227 0000009E BC0C            POP              {R2,R3}
  228 000000A0         
  229 000000A0 F3EF 8600       MRS              R6,APSR
  230 000000A4 2B00    AddLoop CMP              R3,#0
  231 000000A6 DD09            BLE              AddDone
  232 000000A8         ; Load the next words into R4 and R5
  233 000000A8 C910            LDM              R1!,{R4}
  234 000000AA CA20            LDM              R2!,{R5}
  235 000000AC         
  236 000000AC 1E5B            SUBS             R3,R3,#1    ; Decrement counter
                                                            
  237 000000AE F386 8800       MSR              APSR,R6
  238 000000B2 416C            ADCS             R4,R4,R5    ; Add the numbers a
                                                            nd set the status f
                                                            lags
  239 000000B4 F3EF 8600       MRS              R6,APSR
  240 000000B8 C010            STM              R0!,{R4}    ; Store the sum in 
                                                            the next address 
  241 000000BA E7F3            B                AddLoop
  242 000000BC F386 8800 
                       AddDone MSR              APSR,R6
  243 000000C0 BC7F            POP              {R0-R6}
  244 000000C2 4770            BX               LR
  245 000000C4                 ENDP
  246 000000C4         
  247 000000C4         ; GetHexMulti will get an N-word hexidecimal number
  248 000000C4         ; from the terminal and store it in memory
  249 000000C4         ; Input params:
  250 000000C4         ;    R1: n: number of words in the input
  251 000000C4         ; Output params:
  252 000000C4         ;    R0: address to number input from user
  253 000000C4         ;    APSR C-flag: 0 valid, 1 invalid
  254 000000C4         ; Subroutines used:
  255 000000C4         ;    GetStringSB
  256 000000C4         GetHexMulti
                               PROC             {R1-R12}
  257 000000C4 B57F            PUSH             {R0-R6,LR}
  258 000000C6         
  259 000000C6         ; Clear the output
  260 000000C6 B403            PUSH             {R0,R1}
  261 000000C8 2500            MOVS             R5,#0
  262 000000CA 4209    ClearLoop
                               TST              R1,R1       ; Check if R1 is 0
  263 000000CC D003            BEQ              ClearDone
  264 000000CE 6005            STR              R5,[R0,#0]
  265 000000D0 1D00            ADDS             R0,R0,#4
  266 000000D2 1E49            SUBS             R1,R1,#1    ; Decrement down co
                                                            unter
  267 000000D4 E7F9            B                ClearLoop
  268 000000D6 BC03    ClearDone
                               POP              {R0,R1}
  269 000000D8         
  270 000000D8         ; Allocate string buffer on the stack



ARM Macro Assembler    Page 7 Program Title for Listing Header Goes Here


  271 000000D8         ; We need at least 8*4 + 1, but the
  272 000000D8         ; stack must be moved by multiple of 4
  273 000000D8         ; so 8*5 = 40
  274 000000D8 46EB            MOV              FP,SP       ; Save the position
                                                             of the stack
  275 000000DA B08A            SUB              SP,SP,#40
  276 000000DC 466B            MOV              R3,SP
  277 000000DE         
  278 000000DE         ; Get string input and store it in R2
  279 000000DE B403            PUSH             {R0,R1}
  280 000000E0 0018            MOVS             R0,R3
  281 000000E2 00C9            LSLS             R1,R1,#3
  282 000000E4 1C49            ADDS             R1,R1,#1
  283 000000E6 F7FF FFFE       BL               GetStringSB
  284 000000EA BC03            POP              {R0,R1}
  285 000000EC         
  286 000000EC         ; Go to the end of the string
  287 000000EC 001A            MOVS             R2,R3       ; Store the start o
                                                            f the string in R2
  288 000000EE 781C    GetLenLoop
                               LDRB             R4,[R3,#0]
  289 000000F0 2C00            CMP              R4,#0
  290 000000F2 D001            BEQ              GetHexLen
  291 000000F4 1C5B            ADDS             R3,R3,#1
  292 000000F6 E7FA            B                GetLenLoop
  293 000000F8         GetHexLen
  294 000000F8         ; R3 is now at the end of the string
  295 000000F8         ; Read the string backwards and store the result in the 
                       output
  296 000000F8         ; R0 is the output pointer and will be incremented after
                        4-bytes are read
  297 000000F8         ; Use R4 as a counter for how many characters have been 
                       read
  298 000000F8         ; R5 will be used to create a bit shift and as a tempora
                       ry variable
  299 000000F8 2100            MOVS             R1,#0       ; Use as a counter 
                                                            for the offset of t
                                                            he output word
  300 000000FA 2400    NextWord
                               MOVS             R4,#0       ; Initialize the co
                                                            unter for character
                                                            s
  301 000000FC 1E5B    NextNibble
                               SUBS             R3,R3,#1
  302 000000FE 00A5            LSLS             R5,R4,#2    ; Create a shift 4*
                                                            [Characters read]
  303 00000100 781E            LDRB             R6,[R3,#0]  ; Load the next cha
                                                            racter from the str
                                                            ing
  304 00000102 F7FF FFFE       BL               FromHex     ; Convert R6 to hex
                                                             value
  305 00000106 D215            BCS              GetHexMultiFail ; If conversion
                                                             fails go to failur
                                                            e branch
  306 00000108 40AE            LSLS             R6,R6,R5    ; Shift the variabl
                                                            e to the correct po
                                                            sition in the word
  307 0000010A 5845            LDR              R5,[R0,R1]  ; Load the current 
                                                            output word



ARM Macro Assembler    Page 8 Program Title for Listing Header Goes Here


  308 0000010C 4335            ORRS             R5,R5,R6    ; Append this nibbl
                                                            e to the current wo
                                                            rd
  309 0000010E 5045            STR              R5,[R0,R1]  ; Store the nibble
  310 00000110 1C64            ADDS             R4,R4,#1    ; Increment the cha
                                                            racter counter
  311 00000112 4293            CMP              R3,R2       ; Check if we just 
                                                            read the first char
                                                            acter in the input 
                                                            string
  312 00000114 D003            BEQ              GetHexMultiDone ; If it was the
                                                             first, we are done
                                                            
  313 00000116 2C08            CMP              R4,#8       ; Check if we read 
                                                            an entire word yet
  314 00000118 D3F0            BLO              NextNibble  ; If we haven't con
                                                            tinue reading into 
                                                            this word
  315 0000011A 1D09            ADDS             R1,R1,#4    ; Go to the next wo
                                                            rd
  316 0000011C E7ED            B                NextWord
  317 0000011E 46DD    GetHexMultiDone
                               MOV              SP,FP       ; Restore the stack
                                                             position
  318 00000120         ; Clear C-flag to indicate success
  319 00000120 B40C            PUSH             {R2,R3}
  320 00000122 F3EF 8200       MRS              R2,APSR
  321 00000126 2320            MOVS             R3,#0x20
  322 00000128 061B            LSLS             R3,R3,#24
  323 0000012A 439A            BICS             R2,R2,R3
  324 0000012C F382 8800       MSR              APSR,R2
  325 00000130 BC0C            POP              {R2,R3}
  326 00000132 BD7F            POP              {R0-R6,PC}
  327 00000134 46DD    GetHexMultiFail
                               MOV              SP,FP       ; Keep the C-flag s
                                                            et
  328 00000136 BD7F            POP              {R0-R6,PC}
  329 00000138                 ENDP
  330 00000138         
  331 00000138         ; PutNumHexMulti will take N-word integer and
  332 00000138         ; print the hexidecimal represenation
  333 00000138         ; Input params:
  334 00000138         ;     R0: pointer to the word array
  335 00000138         ;     R1: Number of words in integer
  336 00000138         ; Output params: (none)
  337 00000138         ; Subroutines used: PutNumHex
  338 00000138         PutNumHexMulti
                               PROC             {R0-R12}
  339 00000138 B507            PUSH             {R0-R2,LR}
  340 0000013A 0002            MOVS             R2,R0       ; Use R2 as the poi
                                                            nter 
  341 0000013C         ; because R0 is a parameter
  342 0000013C         ; to PutNumHex
  343 0000013C         ; Calculate the pointer of the final word
  344 0000013C 0089            LSLS             R1,R1,#2
  345 0000013E 1809            ADDS             R1,R1,R0
  346 00000140 1F09            SUBS             R1,R1,#4
  347 00000142 4291    pnhm_loop
                               CMP              R1,R2       ; Check if we read 



ARM Macro Assembler    Page 9 Program Title for Listing Header Goes Here


                                                            all the words
  348 00000144 DB04            BLT              PutNumHexMultiDone
  349 00000146 6808            LDR              R0,[R1,#0]  ; Load the word int
                                                            o R0 and go to the 
                                                            next word
  350 00000148 F7FF FFFE       BL               PutNumHex   ; Print the word
  351 0000014C 1F09            SUBS             R1,R1,#4
  352 0000014E E7F8            B                pnhm_loop
  353 00000150         PutNumHexMultiDone
  354 00000150 BD07            POP              {R0-R2,PC}
  355 00000152                 ENDP
  356 00000152         
  357 00000152         ; Print a 32-bit number in hex
  358 00000152         ; Subroutines used:
  359 00000152         ;   PutDigHex
  360 00000152         ; Input parameter:
  361 00000152         ;   R0: number to print in hexadecimal (unsigned word va
                       lue)
  362 00000152         ; Output parameter: (none)
  363 00000152         PutNumHex
                               PROC             {R0-R12}
  364 00000152 0000000F 
                       RIGHT_NIBBLE_MASK
                               EQU              0x0F
  365 00000152 B51F            PUSH             {R0-R4,LR}
  366 00000154         ; There are 4 bytes to print
  367 00000154 2100            MOVS             R1,#0       ; Use R1 as an iter
                                                            ator
  368 00000156 2318            MOVS             R3,#24
  369 00000158 240F            MOVS             R4,#RIGHT_NIBBLE_MASK
  370 0000015A 41D8            RORS             R0,R0,R3    ; Move the MSB to t
                                                            he LSB
  371 0000015C 2904    pnh_loop
                               CMP              R1,#4
  372 0000015E DA0A            BGE              pnh_done
  373 00000160         ; Print the most significant nibble
  374 00000160 0902            LSRS             R2,R0,#4
  375 00000162 4022            ANDS             R2,R2,R4
  376 00000164 F7FF FFFE       BL               PutDigHex   ; Print this digit
  377 00000168         ; Print the least significant nibble
  378 00000168 0002            MOVS             R2,R0
  379 0000016A 4022            ANDS             R2,R2,R4
  380 0000016C F7FF FFFE       BL               PutDigHex
  381 00000170 41D8            RORS             R0,R0,R3    ; Move to the next 
                                                            byte
  382 00000172 1C49            ADDS             R1,R1,#1    ; i++
  383 00000174 E7F2            B                pnh_loop
  384 00000176 BD1F    pnh_done
                               POP              {R0-R4,PC}
  385 00000178                 ENDP
  386 00000178         
  387 00000178         ; Print a single hex digit
  388 00000178         ; stored in R2
  389 00000178         ; Subroutines used:
  390 00000178         ;   PutChar
  391 00000178         ; Input parameter:
  392 00000178         ;   R2 Hex digit to print
  393 00000178         PutDigHex
                               PROC             {R0-R12}



ARM Macro Assembler    Page 10 Program Title for Listing Header Goes Here


  394 00000178 0000000A 
                       ASCII_LETTER
                               EQU              10          ; Any values greate
                                                            r than or equal to 
                                                            this will be a lett
                                                            er A-F
  395 00000178 00000030 
                       ASCII_DIG_OFF
                               EQU              '0'
  396 00000178 00000039 
                       ASCII_DIG_LAST
                               EQU              '9'
  397 00000178 00000007 
                       ASCII_LET_OFF
                               EQU              ('A' - '0' - 10)
  398 00000178 B50D            PUSH             {R0,R2,R3,LR}
  399 0000017A 230F            MOVS             R3,#0x0F
  400 0000017C 401A            ANDS             R2,R2,R3
  401 0000017E 3230            ADDS             R2,#ASCII_DIG_OFF
  402 00000180 2A39            CMP              R2,#ASCII_DIG_LAST
  403 00000182 DD00            BLE              put_dig
  404 00000184 1DD2            ADDS             R2,R2,#ASCII_LET_OFF
  405 00000186 0010    put_dig MOVS             R0,R2
  406 00000188 F7FF FFFE       BL               PutChar
  407 0000018C BD0D            POP              {R0,R2,R3,PC}
  408 0000018E                 ENDP
  409 0000018E         
  410 0000018E         ; ToUpper will convert an ASCII character to uppercase
  411 0000018E         ; If the input character is not lowercase it will not ch
                       ange it
  412 0000018E         ; Input Params:
  413 0000018E         ;       R6: Input character
  414 0000018E         ; Ouptut Params:
  415 0000018E         ;       R6: Upper-case character
  416 0000018E         ; Subroutines used: (none)
  417 0000018E         ToUpper PROC             {R0-R5,R7-R12}
  418 0000018E 00000061 
                       AS_L_S  EQU              'a'
  419 0000018E 0000007A 
                       AS_L_E  EQU              'z'
  420 0000018E 00000041 
                       AS_U_S  EQU              'A'
  421 0000018E         ; Check if character is lowercase
  422 0000018E 2E7A            CMP              R6,#AS_L_E
  423 00000190 DC02            BGT              ToUpperDone ; Not a lowercase c
                                                            haracter
  424 00000192 2E61            CMP              R6,#AS_L_S
  425 00000194 DB00            BLT              ToUpperDone ; Already in upperc
                                                            ase or not an alpha
                                                             character
  426 00000196         ; Convert to upper case
  427 00000196 3E20            SUBS             R6,R6,#(AS_L_S - AS_U_S)
  428 00000198 4770    ToUpperDone
                               BX               LR
  429 0000019A                 ENDP
  430 0000019A         
  431 0000019A         
  432 0000019A         ; FromHex will convert an ASCII hexidecimal character to
                        binary



ARM Macro Assembler    Page 11 Program Title for Listing Header Goes Here


  433 0000019A         ; If the ASCII character is not a valid hexidecimal valu
                       e, a
  434 0000019A         ; failure condition will be set (APSR-C)
  435 0000019A         ; Input Params:
  436 0000019A         ;       R6: ascii character
  437 0000019A         ; Output Params:
  438 0000019A         ;       R6: hex digit conversion
  439 0000019A         ;       APSR-C: 0 (success), 1 (failure)
  440 0000019A         ; Subroutines used: ToUpper
  441 0000019A         FromHex PROC             {R0-R5,R7-R12}
  442 0000019A B500            PUSH             {LR}
  443 0000019C F7FF FFFE       BL               ToUpper     ; Convert R3 to upp
                                                            ercase
  444 000001A0 2E41            CMP              R6,#AS_U_S  ; Check if A-Z or 0
                                                            -9
  445 000001A2 DB03            BLT              FromHex09
  446 000001A4         ; R6 is A-Z
  447 000001A4 2E46            CMP              R6,#'F'
  448 000001A6 DC07            BGT              FromHexFail ; Not a valid hexid
                                                            emical character
  449 000001A8 3E37            SUBS             R6,R6,#(AS_U_S - 10) 
                                                            ; Convert to digit
  450 000001AA E00E            B                FromHexDone
  451 000001AC 2E30    FromHex09
                               CMP              R6,#'0'
  452 000001AE DB03            BLT              FromHexFail ; Not a valid hexid
                                                            emical character
  453 000001B0 2E39            CMP              R6,#'9'
  454 000001B2 DC01            BGT              FromHexFail ; Not a valid hexid
                                                            emical character
  455 000001B4 3E30            SUBS             R6,R6,#'0'  ; Convert digit
  456 000001B6 E008            B                FromHexDone
  457 000001B8         FromHexFail                          ; Set C-flag to ind
                                                            icate failure
  458 000001B8 B40C            PUSH             {R2,R3}
  459 000001BA F3EF 8200       MRS              R2,APSR
  460 000001BE 2320            MOVS             R3,#0x20
  461 000001C0 061B            LSLS             R3,R3,#24
  462 000001C2 431A            ORRS             R2,R2,R3
  463 000001C4 F382 8800       MSR              APSR,R2
  464 000001C8 BD0C            POP              {R2,R3,PC}
  465 000001CA         FromHexDone                          ; Clear C-flag to i
                                                            ndicate Success
  466 000001CA B40C            PUSH             {R2,R3}
  467 000001CC F3EF 8200       MRS              R2,APSR
  468 000001D0 2320            MOVS             R3,#0x20
  469 000001D2 061B            LSLS             R3,R3,#24
  470 000001D4 439A            BICS             R2,R2,R3
  471 000001D6 F382 8800       MSR              APSR,R2
  472 000001DA BD0C            POP              {R2,R3,PC}
  473 000001DC                 ENDP
  474 000001DC         
  475 000001DC         ; PutChar will print a character to the terminal
  476 000001DC         ; Subroutines used: (none)
  477 000001DC         ; Input: R0 (character to print)
  478 000001DC         ; Output; None
  479 000001DC         ; Register modification list: R1-R3
  480 000001DC         PutChar PROC             {R0-R12}
  481 000001DC B40E            PUSH             {R1-R3}



ARM Macro Assembler    Page 12 Program Title for Listing Header Goes Here


  482 000001DE         
  483 000001DE         ; Wait until last character has been sent
  484 000001DE         ;Set Z if TDRE=0
  485 000001DE 498F            LDR              R1,=UART0_BASE
  486 000001E0 2280            MOVS             R2,#UART0_S1_TDRE_MASK
  487 000001E2 790B    putchar_l
                               LDRB             R3,[R1,#UART0_S1_OFFSET]
  488 000001E4 421A            TST              R2,R3
  489 000001E6 D0FC            BEQ              putchar_l
  490 000001E8         
  491 000001E8         ; Write the character to the terminal
  492 000001E8 71C8            STRB             R0,[R1,#UART0_D_OFFSET]
  493 000001EA         
  494 000001EA BC0E            POP              {R1-R3}
  495 000001EC 4770            BX               LR
  496 000001EE                 ENDP
  497 000001EE         
  498 000001EE         ; GetChar will real a character from the terminal
  499 000001EE         ; Subroutines used: (none)
  500 000001EE         ; Input: None
  501 000001EE         ; Output; R0 (character read from terminal)
  502 000001EE         ; Register modification list: R1-R3
  503 000001EE         GetChar PROC             {R1-R12}
  504 000001EE B40E            PUSH             {R1-R3}
  505 000001F0         
  506 000001F0         ; Wait until a character is ready
  507 000001F0         ;Set Z if RDRF=0
  508 000001F0 498A            LDR              R1,=UART0_BASE
  509 000001F2 2220            MOVS             R2,#UART0_S1_RDRF_MASK
  510 000001F4 790B    getchar_l
                               LDRB             R3,[R1,#UART0_S1_OFFSET]
  511 000001F6 421A            TST              R2,R3
  512 000001F8 D0FC            BEQ              getchar_l
  513 000001FA         
  514 000001FA         ; Read the value from the data register
  515 000001FA 79C8            LDRB             R0,[R1,#UART0_D_OFFSET]
  516 000001FC         
  517 000001FC BC0E            POP              {R1-R3}
  518 000001FE 4770            BX               LR
  519 00000200                 ENDP
  520 00000200         
  521 00000200         ; Recieve a string from the command line terminated by C
                       R. 
  522 00000200         ; This should null terminate the string and shouldn't 
  523 00000200         ; overflow over the maxmimum size specified in R1.
  524 00000200         ; SUBROUTINES USED
  525 00000200         ;   - GetChar (recieve input)
  526 00000200         ;   - PutChar (Print each character as we get them)
  527 00000200         ; PARAMS
  528 00000200         ;   INPUT R0: pointer to the destination buffer (word ad
                       dress)
  529 00000200         ;   INPUT R1: size of the destination buffer    (unsigne
                       d word value)
  530 00000200         ;   OUTPUT  : String buffer stored in memory at R0
  531 00000200         GetStringSB
                               PROC             {R0-R3}
  532 00000200 B50F            PUSH             {R0-R3,LR}
  533 00000202         ; get_string_sb(char* str, size_t r1) {
  534 00000202         ;   char* ptr = str



ARM Macro Assembler    Page 13 Program Title for Listing Header Goes Here


  535 00000202         ;   while ((c = getchar()) != '\r')
  536 00000202         ;       if (ptr - str < r1 - 1)
  537 00000202         ;           *ptr = getchar();
  538 00000202         ;           printf("%c", *ptr)
  539 00000202         ;           ptr++
  540 00000202         ;   *ptr = '\0'
  541 00000202         ;   printf("\r\n")
  542 00000202 0003            MOVS             R3,R0
  543 00000204 2200            MOVS             R2,#0       ; i = 0 (use a coun
                                                            ter instead of incr
                                                            ementing R3)
  544 00000206 1E49            SUBS             R1,R1,#1
  545 00000208 F7FF FFFE 
                       getwhile
                               BL               GetChar     ; c = getchar()
  546 0000020C 280D            CMP              R0,#'\r'    ; while (c != '\r')
                                                            
  547 0000020E D006            BEQ              getdone     ; break
  548 00000210 428A            CMP              R2,R1
  549 00000212 DAF9            BGE              getwhile    ; if (i >= r1 - 1) 
                                                            continue
  550 00000214 5498            STRB             R0,[R3,R2]  ; r3[i] = r0
  551 00000216 F7FF FFFE       BL               PutChar     ; printf("%c", r0);
                                                            
  552 0000021A 1C52            ADDS             R2,R2,#1    ; i++
  553 0000021C E7F4            B                getwhile
  554 0000021E 2000    getdone MOVS             R0,#0       ; Add null terminat
                                                            or
  555 00000220 5498            STRB             R0,[R3,R2]
  556 00000222         
  557 00000222         ; print new line (Windows CRLF)
  558 00000222 200D            MOVS             R0,#'\r'
  559 00000224 F7FF FFFE       BL               PutChar
  560 00000228 200A            MOVS             R0,#'\n'
  561 0000022A F7FF FFFE       BL               PutChar
  562 0000022E BD0F            POP              {PC,R0-R3}
  563 00000230                 ENDP
  564 00000230         
  565 00000230         ; Print a NULL terminated string
  566 00000230         ; SUBROUTINES USED
  567 00000230         ;   - PutChar (Print each character)
  568 00000230         ; PARAMS
  569 00000230         ;   INPUT R0: pointer to the target string (word address
                       )
  570 00000230         ;   INPUT R1: size of the string buffer so that to not o
                       verflow (unsigned word value)
  571 00000230         ;   OUTPUT  : NONE
  572 00000230         PutStringSB
                               PROC             {R0-R12}
  573 00000230 B51F            PUSH             {R0-R4,LR}
  574 00000232         ; put_string_sb(char* r0, size_t r1)
  575 00000232         ;   iter = r0
  576 00000232         ;   while (*iter && iter - r0 < r1 - 1)
  577 00000232         ;       printf("%c", *iter)
  578 00000232         ;       iter++
  579 00000232 0002            MOVS             R2,R0       ; iter = r0
  580 00000234 0004            MOVS             R4,R0       ; start = r0 (r0 ne
                                                            eds to be used for 
                                                            printing)



ARM Macro Assembler    Page 14 Program Title for Listing Header Goes Here


  581 00000236 1E49            SUBS             R1,R1,#1
  582 00000238         
  583 00000238 7813    putwhile
                               LDRB             R3,[R2,#0]  ; r3 = *iter
  584 0000023A 2B00            CMP              R3,#0       ; if (!*r3) break
  585 0000023C D007            BEQ              putdone
  586 0000023E 1B13            SUBS             R3,R2,R4
  587 00000240 428B            CMP              R3,R1       ; if (iter - start 
                                                            >= r1 - 1) break
  588 00000242 DA04            BGE              putdone
  589 00000244 7810            LDRB             R0,[R2,#0]  ; r0 = *iter
  590 00000246 F7FF FFFE       BL               PutChar     ; printf("%c", *ite
                                                            r);
  591 0000024A 1C52            ADDS             R2,R2,#1    ; iter++
  592 0000024C E7F4            B                putwhile
  593 0000024E BD1F    putdone POP              {R0-R4,PC}
  594 00000250                 ENDP
  595 00000250         
  596 00000250         ; Initialize the UART0 serial polling with
  597 00000250         ; 8 databits, no parity, one stop bit
  598 00000250         ; Subroutines used: (none)
  599 00000250         ; Input: None
  600 00000250         ; Output: None
  601 00000250         ; Register modification: R0-R2
  602 00000250         Init_UART0_Polling
                               PROC             {R3-R12}
  603 00000250 B407            PUSH             {R0-R2}
  604 00000252         ; Select/configure UART0 sources
  605 00000252 04000000 
                       SIM_SOPT2_UART0SRC_MCGFLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
  606 00000252         ; Set the UART0 clock to 48 MHz
  607 00000252 4873            LDR              R0,=SIM_SOPT2
  608 00000254 4973            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  609 00000256 6802            LDR              R2,[R0,#0]  ;current SIM_SOPT2v
                                                            alue
  610 00000258 438A            BICS             R2,R2,R1    ;only UART0SRCbits 
                                                            cleared
  611 0000025A 4973            LDR              R1,=SIM_SOPT2_UART0SRC_MCGFLLCL
K
  612 0000025C 430A            ORRS             R2,R2,R1    ;only UART0 bits ch
                                                            anged
  613 0000025E 6002            STR              R2,[R0,#0]  ;update SIM_SOPT2
  614 00000260         
  615 00000260         ; Set SIM_SOPT5 for UART0 External
  616 00000260 00010005 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR: S
IM_SOPT5_UART0RXSRC_MASK :OR: SIM_SOPT5_UART0TXSRC_MASK)
  617 00000260 4872            LDR              R0,=SIM_SOPT5
  618 00000262 4973            LDR              R1,=SIM_SOPT5_UART0_EXTERN_MASK
_CLEAR
  619 00000264 6802            LDR              R2,[R0,#0]  ;current SIM_SOPT5v
                                                            alue
  620 00000266 438A            BICS             R2,R2,R1    ;only UART0 bits cl
                                                            eared
  621 00000268 6002            STR              R2,[R0,#0]  ;update SIM_SOPT5
  622 0000026A         
  623 0000026A         ; Enable clocks for UART0 and Port B



ARM Macro Assembler    Page 15 Program Title for Listing Header Goes Here


  624 0000026A         ; Enable UART0 clocks
  625 0000026A 4872            LDR              R0,=SIM_SCGC4
  626 0000026C 4972            LDR              R1,=SIM_SCGC4_UART0_MASK
  627 0000026E 6802            LDR              R2,[R0,#0]  ;current SIM_SCGC4v
                                                            alue
  628 00000270 430A            ORRS             R2,R2,R1    ;only UART0bit set
  629 00000272 6002            STR              R2,[R0,#0]  ;update SIM_SCGC4
  630 00000274         
  631 00000274         ; Set SIM_CGC5 for Port B Clock Enabled
  632 00000274 4871            LDR              R0,=SIM_SCGC5
  633 00000276 4970            LDR              R1,=SIM_SCGC5_PORTB_MASK
  634 00000278 6802            LDR              R2,[R0,#0]  ;current SIM_SCGC5v
                                                            alue
  635 0000027A 430A            ORRS             R2,R2,R1    ;only PORTBbit set
  636 0000027C 6002            STR              R2,[R0,#0]  ;update SIM_SCGC5
  637 0000027E         
  638 0000027E         ; Select Port B mux pins to connect to UART0
  639 0000027E 01000200 
                       PORT_PCR_SET_PTB2_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR: PORT_PC
R_MUX_SELECT_2_MASK)
  640 0000027E 01000200 
                       PORT_PCR_SET_PTB1_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR: PORT_PC
R_MUX_SELECT_2_MASK)
  641 0000027E         
  642 0000027E 4870            LDR              R0,=PORTB_PCR2
  643 00000280 4970            LDR              R1,=PORT_PCR_SET_PTB2_UART0_RX
  644 00000282 6001            STR              R1,[R0,#0]  ;Port B pin 2 conne
                                                            cts to UART0 Rx
  645 00000284 4870            LDR              R0,=PORTB_PCR1
  646 00000286 496F            LDR              R1,=PORT_PCR_SET_PTB1_UART0_TX
  647 00000288 6001            STR              R1,[R0,#0]  ;Port B pin 1 conne
                                                            cts to UART0 Tx
  648 0000028A         
  649 0000028A         ; Configure UART0 (register initialization)
  650 0000028A         ; Load base addr for UART0
  651 0000028A 4864            LDR              R0,=UART0_BASE
  652 0000028C         
  653 0000028C         ; Disable UART0
  654 0000028C         
  655 0000028C         
  656 0000028C 210C            MOVS             R1,#UART0_C2_T_R
  657 0000028E 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  658 00000290 438A            BICS             R2,R2,R1
  659 00000292 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  660 00000294         
  661 00000294         ; Set UART0 baud rate?BDH before BDL
  662 00000294 2101            MOVS             R1,#UART0_BDH_9600
  663 00000296 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  664 00000298 2138            MOVS             R1,#UART0_BDL_9600
  665 0000029A 7041            STRB             R1,[R0,#UART0_BDL_OFFSET]
  666 0000029C         
  667 0000029C         ; Set UART0 character format for serial bit stream and c
                       lear flags
  668 0000029C 2100            MOVS             R1,#UART0_C1_8N1
  669 0000029E 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  670 000002A0 2100            MOVS             R1,#UART0_C3_NO_TXINV
  671 000002A2 7181            STRB             R1,[R0,#UART0_C3_OFFSET]



ARM Macro Assembler    Page 16 Program Title for Listing Header Goes Here


  672 000002A4 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  673 000002A6 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  674 000002A8 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  675 000002AA 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  676 000002AC 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  677 000002AE 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  678 000002B0 21C0            MOVS             R1,#UART0_S2_NO_RXINV_BRK10_NO_
LBKDETECT_CLEAR_FLAGS
  679 000002B2 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  680 000002B4         
  681 000002B4         ; Enable UART0
  682 000002B4 210C            MOVS             R1,#UART0_C2_T_R
  683 000002B6 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  684 000002B8         
  685 000002B8 BC07            POP              {R0-R2}
  686 000002BA 4770            BX               LR
  687 000002BC                 ENDP
  688 000002BC         
  689 000002BC         ; This subroutine is a printf() clone with the following
                       
  690 000002BC         ; formats defined:
  691 000002BC         ;    %x: hex
  692 000002BC         ;    %d: decimal
  693 000002BC         ;    %s: string
  694 000002BC         ;    %b: single byte decimal
  695 000002BC         ;    %c: char
  696 000002BC         ; Subroutines used:
  697 000002BC         ;    PutChar
  698 000002BC         ;    PutNumHex (%x)
  699 000002BC         ;    PutNumU   (%d)
  700 000002BC         ;    PutStringSB (%s)
  701 000002BC         ;    PutNumUB (%b)
  702 000002BC         ;    printf (recursive call on error)
  703 000002BC         ; Input Registers:
  704 000002BC         ;    R1: Pointer to the format string
  705 000002BC         ;    N variables on the stack that correspond 
  706 000002BC         ;    to arguments in the format string
  707 000002BC         ; Output (None)
  708 000002BC         ; Modified Registers (None)
  709 000002BC         printf  PROC             {R0-R12}
  710 000002BC         ; Because the stack is used to pass parameters to
  711 000002BC         ; this subroutines. We can't modify the stack pointer
  712 000002BC         ; before moving through the format string.
  713 000002BC         ; Use the memory as a stack
  714 000002BC B420            PUSH             {R5}
  715 000002BE 4D53            LDR              R5,=printf_static
  716 000002C0 6028            STR              R0,[R5,#0]
  717 000002C2 6069            STR              R1,[R5,#4]
  718 000002C4 60AA            STR              R2,[R5,#8]
  719 000002C6 60EB            STR              R3,[R5,#12]
  720 000002C8 612C            STR              R4,[R5,#16]
  721 000002CA BC20            POP              {R5}
  722 000002CC         
  723 000002CC         ; Store the return pointer
  724 000002CC B500            PUSH             {LR}
  725 000002CE BC10            POP              {R4}
  726 000002D0         
  727 000002D0 780A    printf_loop
                               LDRB             R2,[R1,#0]



ARM Macro Assembler    Page 17 Program Title for Listing Header Goes Here


  728 000002D2 4212            TST              R2,R2
  729 000002D4 D032            BEQ              printf_end  ;  End of string
  730 000002D6 2A25            CMP              R2,#'%'     ; Format character
  731 000002D8 D003            BEQ              printf_fmt
  732 000002DA 0010            MOVS             R0,R2
  733 000002DC F7FF FFFE       BL               PutChar
  734 000002E0 E02A            B                printf_continue
  735 000002E2 1C49    printf_fmt
                               ADDS             R1,R1,#1
  736 000002E4 780A            LDRB             R2,[R1,#0]
  737 000002E6 2A78            CMP              R2,#'x'     ; Print a hex strin
                                                            g
  738 000002E8 D00F            BEQ              printf_h
  739 000002EA 2A64            CMP              R2,#'d'     ; Print a decimal s
                                                            tring
  740 000002EC D011            BEQ              printf_d
  741 000002EE 2A73            CMP              R2,#'s'     ; Print a string
  742 000002F0 D013            BEQ              printf_s
  743 000002F2 2A63            CMP              R2,#'c'
  744 000002F4 D01C            BEQ              printf_c
  745 000002F6 2A62            CMP              R2,#'b'     ; Print a single by
                                                            te
  746 000002F8 D016            BEQ              printf_b
  747 000002FA         ; INVALID FORMAT STRING
  748 000002FA         ; Print the error string
  749 000002FA B420            PUSH             {R5}
  750 000002FC 6869            LDR              R1,[R5,#4]
  751 000002FE BC20            POP              {R5}
  752 00000300         
  753 00000300 B402            PUSH             {R1}
  754 00000302 4943            LDR              R1,=invalid
  755 00000304 F7FF FFFE       BL               printf
  756 00000308 E7FE            B                .           ; Invalid format st
                                                            ring (STOP)
  757 0000030A         printf_h                             ; Print the current
                                                             number in R0
  758 0000030A BC01            POP              {R0}
  759 0000030C F7FF FFFE       BL               PutNumHex
  760 00000310 E012            B                printf_continue
  761 00000312         printf_d                             ; Print the current
                                                             digit in R0
  762 00000312 BC01            POP              {R0}
  763 00000314 F7FF FFFE       BL               PutNumU
  764 00000318 E00E            B                printf_continue
  765 0000031A         printf_s                             ; Print the string 
                                                            in R0
  766 0000031A BC01            POP              {R0}
  767 0000031C B402            PUSH             {R1}
  768 0000031E 2164            MOVS             R1,#100     ; Max string length
                                                             of 100
  769 00000320 F7FF FFFE       BL               PutStringSB
  770 00000324 BC02            POP              {R1}
  771 00000326 E007            B                printf_continue
  772 00000328         printf_b                             ; Print the single 
                                                            byte value in R0
  773 00000328 BC01            POP              {R0}
  774 0000032A F7FF FFFE       BL               PutNumUB
  775 0000032E E003            B                printf_continue
  776 00000330         printf_c                             ; Print the single 



ARM Macro Assembler    Page 18 Program Title for Listing Header Goes Here


                                                            char value in R0
  777 00000330 BC01            POP              {R0}
  778 00000332 F7FF FFFE       BL               PutChar
  779 00000336 E7FF            B                printf_continue
  780 00000338 1C49    printf_continue
                               ADDS             R1,R1,#1
  781 0000033A E7C9            B                printf_loop
  782 0000033C         printf_end                           ; Restore the link 
                                                            register
  783 0000033C B410            PUSH             {R4}        ; This will be POP'
                                                            ed to PC
  784 0000033E         
  785 0000033E         ; Restore registers from memory
  786 0000033E B420            PUSH             {R5}
  787 00000340 4D32            LDR              R5,=printf_static
  788 00000342 6828            LDR              R0,[R5,#0]
  789 00000344 6869            LDR              R1,[R5,#4]
  790 00000346 68AA            LDR              R2,[R5,#8]
  791 00000348 68EB            LDR              R3,[R5,#12]
  792 0000034A 692C            LDR              R4,[R5,#16]
  793 0000034C BC20            POP              {R5}
  794 0000034E         
  795 0000034E BD00            POP              {PC}
  796 00000350                 ENDP
  797 00000350         
  798 00000350         ; Prints to the terminal screen the decimal representati
                       on of the
  799 00000350         ; unsigned byte value in R0
  800 00000350         ; Subroutines Used:
  801 00000350         ;  PutNumU
  802 00000350         ; Input parameter:
  803 00000350         ;   R0:number to print in decimal (unsigned byte value)
  804 00000350         ;Output parameter: (none)
  805 00000350         PutNumUB
                               PROC             {R0-R12}
  806 00000350 B503            PUSH             {R0,R1,LR}
  807 00000352 21FF            MOVS             R1,#BYTE_MASK
  808 00000354 4008            ANDS             R0,R0,R1
  809 00000356 F7FF FFFE       BL               PutNumU
  810 0000035A BD03            POP              {R0,R1,PC}
  811 0000035C                 ENDP
  812 0000035C         
  813 0000035C         ; Print a number in decimal using the ascii
  814 0000035C         ; characters
  815 0000035C         ; SUBROUTINES USED
  816 0000035C         ;   - PutChar (Print each digit)
  817 0000035C         ;   - DIVU
  818 0000035C         ; PARAMS
  819 0000035C         ;   INPUT R0: Number to print (unsigned word value)
  820 0000035C         ;   OUTPUT  : NONE
  821 0000035C         PutNumU PROC             {R0-R12}
  822 0000035C B507            PUSH             {R0-R2,LR}
  823 0000035E 0000000A 
                       printbase
                               EQU              10
  824 0000035E 00000030 
                       asciioffset
                               EQU              '0'
  825 0000035E         ; put_num_u(U32 r0)



ARM Macro Assembler    Page 19 Program Title for Listing Header Goes Here


  826 0000035E         ; while (r0 != 0)
  827 0000035E         ;   (add r0 % 10 to stack)
  828 0000035E         ;   r0 /= 10
  829 0000035E         ; print the stack backwards
  830 0000035E 2800            CMP              R0,#0       ; Just print a '0'
  831 00000360 D011            BEQ              numzero
  832 00000362         
  833 00000362 2200            MOVS             R2,#0       ; Count the number 
                                                            of digits
  834 00000364 2800    numwhile
                               CMP              R0,#0       ; while (r0 != 0)
  835 00000366 D005            BEQ              numwhile2
  836 00000368 210A            MOVS             R1,#printbase ; Always divide b
                                                            y the base
  837 0000036A F7FF FFFE       BL               DIVU        ; R0 = R0 / base; R
                                                            0 % base
  838 0000036E B402            PUSH             {R1}        ; Need to print the
                                                            se digits backwards
                                                            
  839 00000370 1C52            ADDS             R2,R2,#1    ; r2++
  840 00000372 E7F7            B                numwhile
  841 00000374 2A01    numwhile2
                               CMP              R2,#1       ; while (r2 >= 1)
  842 00000376 DB09            BLT              numdone
  843 00000378 BC02            POP              {R1}
  844 0000037A 0008            MOVS             R0,R1
  845 0000037C 3030            ADDS             R0,R0,#asciioffset ; Print the 
                                                            next character (asc
                                                            ii not just value)
  846 0000037E 1E52            SUBS             R2,R2,#1
  847 00000380 F7FF FFFE       BL               PutChar
  848 00000384 E7F6            B                numwhile2
  849 00000386 2030    numzero MOVS             R0,#'0'
  850 00000388 F7FF FFFE       BL               PutChar
  851 0000038C BD07    numdone POP              {R0-R2,PC}
  852 0000038E                 ENDP
  853 0000038E         
  854 0000038E         ; Calculate the quotient and remainder of
  855 0000038E         ; two unsigned word values.
  856 0000038E         ; SUBROUTINES: None
  857 0000038E         ; PARAMS:
  858 0000038E         ;   INPUT R0: dividend (unsigned word)
  859 0000038E         ;   INPUT R1: divisor  (unsigned word)
  860 0000038E         ;   OUTPUT R0: quotient (unsigned word)
  861 0000038E         ;   OUTPUT R1: remainder (unsigned word)
  862 0000038E         DIVU    PROC             {R2-R12}
  863 0000038E B500            PUSH             {LR}
  864 00000390 B4FC            PUSH             {R2-R7}
  865 00000392 2900            CMP              R1,#0
  866 00000394 D01D            BEQ              DIVU_0      ; Don't try to divi
                                                            de by zero
  867 00000396 00000080 
                       LEFT_MASK
                               EQU              0x80        ; Used to get most 
                                                            significant bit of 
                                                            a byte
  868 00000396 0000001F 
                       SHIFT32 EQU              31
  869 00000396         ; Compute N / D



ARM Macro Assembler    Page 20 Program Title for Listing Header Goes Here


  870 00000396         ; Use binary long division
  871 00000396         ; R = 0 (Use R2)
  872 00000396         ; Q = 0 (Use R3)
  873 00000396         ; for (i = 31; i >= 0; i--) {
  874 00000396         ;   R = R << 1
  875 00000396         ;   R |= (N & LEFT_MASK) >> 31
  876 00000396         ;   N = N << 1
  877 00000396         ;   if R >= D {
  878 00000396         ;       R = R - D
  879 00000396         ;       Q |= 1 << i
  880 00000396         ;   }
  881 00000396         ; }
  882 00000396 2200            MOVS             R2,#0       ; Init Remainder
  883 00000398 2300            MOVS             R3,#0       ; Init the Quotient
                                                            
  884 0000039A 241F            MOVS             R4,#SHIFT32 ; Init the iterator
                                                             (i)
  885 0000039C 2601            MOVS             R6,#1       ; Used for Q = Q | 
                                                            (1 << i)
  886 0000039E 2C00    DIV_FOR CMP              R4,#0       ; if (i >= 0)
  887 000003A0 DB0D            BLT              DIVU_FINISH ; Finished loop
  888 000003A2 0052            LSLS             R2,R2,#1    ; R = R << 1
  889 000003A4 0FC5            LSRS             R5,R0,#SHIFT32 ; R5 = most sign
                                                            ificant bit in N
  890 000003A6 2601            MOVS             R6,#1
  891 000003A8 4035            ANDS             R5,R5,R6    ; R5 = (N & LEFT_MA
                                                            SK) >> 31
  892 000003AA 432A            ORRS             R2,R2,R5    ; R |= (N & LEFT_MA
                                                            SK) >> 31
  893 000003AC 0040            LSLS             R0,R0,#1    ; N = N << 1
  894 000003AE 428A            CMP              R2,R1       ; if (R >= D)
  895 000003B0 D303            BLO              DIV_ITER    ; continue;
  896 000003B2 1A52            SUBS             R2,R2,R1    ; R = R - D
  897 000003B4 40A6            LSLS             R6,R6,R4    ; R6 = 1 << i
  898 000003B6 0035            MOVS             R5,R6
  899 000003B8 432B            ORRS             R3,R3,R5    ; Q = Q | (1 << i)
  900 000003BA 1E64    DIV_ITER
                               SUBS             R4,R4,#1    ; i--
  901 000003BC E7EF            B                DIV_FOR     ; For loop
  902 000003BE 0018    DIVU_FINISH
                               MOVS             R0,R3       ; Set the outputs
  903 000003C0 0011            MOVS             R1,R2       ;
  904 000003C2         ; Clear the carry flag
  905 000003C2 F3EF 8200       MRS              R2,APSR
  906 000003C6 2320            MOVS             R3,#0x20
  907 000003C8 061B            LSLS             R3,R3,#24
  908 000003CA 439A            BICS             R2,R2,R3
  909 000003CC F382 8800       MSR              APSR,R2
  910 000003D0 E007            B                DIVU_STOP
  911 000003D2 2301    DIVU_0  MOVS             R3,#1       ; Init R3 as 1
  912 000003D4         ; Set the carry flag
  913 000003D4 F3EF 8200       MRS              R2,APSR
  914 000003D8 2320            MOVS             R3,#0x20
  915 000003DA 061B            LSLS             R3,R3,#24
  916 000003DC 431A            ORRS             R2,R2,R3
  917 000003DE F382 8800       MSR              APSR,R2
  918 000003E2 BCFC    DIVU_STOP
                               POP              {R2-R7}
  919 000003E4 BD00            POP              {PC}



ARM Macro Assembler    Page 21 Program Title for Listing Header Goes Here


  920 000003E6                 ENDP
  921 000003E6         
  922 000003E6         
  923 000003E6         ;>>>>>   end subroutine code <<<<<
  924 000003E6 00 00           ALIGN
  925 000003E8         ;*******************************************************
                       *********
  926 000003E8         ;Vector Table Mapped to Address 0 at Reset
  927 000003E8         ;Linker requires __Vectors to be exported
  928 000003E8 00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              4006A000 
              40048004 
              0C000000 
              04000000 
              40048010 
              00010005 
              40048034 
              00000400 
              40048038 
              4004A008 
              01000200 
              4004A004 
              00000000 
              00000000 
              00000000         AREA             RESET, DATA, READONLY
  929 00000000                 EXPORT           __Vectors
  930 00000000                 EXPORT           __Vectors_End
  931 00000000                 EXPORT           __Vectors_Size
  932 00000000                 IMPORT           __initial_sp
  933 00000000                 IMPORT           Dummy_Handler
  934 00000000                 IMPORT           HardFault_Handler
  935 00000000         __Vectors
  936 00000000         ;ARM core vectors
  937 00000000 00000000        DCD              __initial_sp ;00:end of stack
  938 00000004 00000000        DCD              Reset_Handler ;01:reset vector
  939 00000008 00000000        DCD              Dummy_Handler ;02:NMI
  940 0000000C 00000000        DCD              HardFault_Handler 
                                                            ;03:hard fault
  941 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
  942 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
  943 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)
  944 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
  945 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
  946 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
  947 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
  948 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (super
                                                            visor call)



ARM Macro Assembler    Page 22 Program Title for Listing Header Goes Here


  949 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
  950 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)
  951 00000038 00000000        DCD              Dummy_Handler ;14:PendSV (Penda
                                                            bleSrvReq)
  952 0000003C         ;   pendable request 
  953 0000003C         ;   for system service)
  954 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (syst
                                                            em tick timer)
  955 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0
                                                             transfer 
  956 00000044         ;   complete/error
  957 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1
                                                             transfer
  958 00000048         ;   complete/error
  959 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2
                                                             transfer
  960 0000004C         ;   complete/error
  961 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3
                                                             transfer
  962 00000050         ;   complete/error
  963 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
  964 00000054 00000000        DCD              Dummy_Handler ;21:FTFA command 
                                                            complete/
  965 00000058         ;   read collision
  966 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage d
                                                            etect;
  967 0000005C         ;   low-voltage warning
  968 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage w
                                                            akeup
  969 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
  970 00000064 00000000        DCD              Dummy_Handler ;25:(reserved)
  971 00000068 00000000        DCD              Dummy_Handler ;26:SPI0
  972 0000006C 00000000        DCD              Dummy_Handler ;27:(reserved)
  973 00000070 00000000        DCD              Dummy_Handler ;28:UART0 (status
                                                            ; error)
  974 00000074 00000000        DCD              Dummy_Handler ;29:(reserved)
  975 00000078 00000000        DCD              Dummy_Handler ;30:(reserved)
  976 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
  977 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
  978 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
  979 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
  980 0000008C 00000000        DCD              Dummy_Handler ;35:(reserved)
  981 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
  982 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
                                                            
  983 00000098 00000000        DCD              Dummy_Handler ;38:PIT
  984 0000009C 00000000        DCD              Dummy_Handler ;39:(reserved)
  985 000000A0 00000000        DCD              Dummy_Handler ;40:(reserved)
  986 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
  987 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
  988 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
  989 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
  990 000000B4 00000000        DCD              Dummy_Handler ;45:(reserved)
  991 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA
  992 000000BC 00000000        DCD              Dummy_Handler ;47:PORTB
  993 000000C0         __Vectors_End
  994 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors



ARM Macro Assembler    Page 23 Program Title for Listing Header Goes Here


  995 000000C0                 ALIGN
  996 000000C0         
  997 000000C0         
  998 000000C0         ;Constants
  999 000000C0                 AREA             MyConst,DATA,READONLY
 1000 00000000 20 45 6E 
              74 65 72 
              20 66 69 
              72 73 74 
              20 31 32 
              38 2D 62 
              69 74 20 
              68 65 78 
              20 6E 75 
              6D 62 65 
              72 3A 20 
              20 30 78 
              00       prompt_1
                               DCB              " Enter first 128-bit hex numbe
r:  0x\0"
 1001 00000025 45 6E 74 
              65 72 20 
              31 32 38 
              2D 62 69 
              74 20 68 
              65 78 20 
              6E 75 6D 
              62 65 72 
              20 74 6F 
              20 61 64 
              64 3A 20 
              20 30 78 
              00       prompt_2
                               DCB              "Enter 128-bit hex number to ad
d:  0x\0"
 1002 0000004A 20 20 20 
              20 20 20 
              49 6E 76 
              61 6C 69 
              64 20 6E 
              75 6D 62 
              65 72 2D 
              2D 74 72 
              79 20 61 
              67 61 69 
              6E 3A 20 
              20 30 78 
              00       prompt_e
                               DCB              "      Invalid number--try agai
n:  0x\0"
 1003 0000006F 20 20 20 
              20 20 20 
              20 20 20 
              20 20 20 
              20 20 20 
              20 20 20 
              20 20 20 
              20 20 20 
              20 20 20 



ARM Macro Assembler    Page 24 Program Title for Listing Header Goes Here


              20 53 75 
              6D 3A 20 
              20 30 78 
              00       sum     DCB              "                            Su
m:  0x\0"
 1004 00000094 0D 0A 0D 
              0A 49 6E 
              76 61 6C 
              69 64 20 
              66 6F 72 
              6D 61 74 
              20 73 74 
              72 69 6E 
              67 20 27 
              25 73 27 
              0D 0A 00 invalid DCB              "\r\n\r\nInvalid format string 
'%s'\r\n\0"
 1005 000000B5 4F 56 45 
              52 46 4C 
              4F 57 00 overflow
                               DCB              "OVERFLOW\0"
 1006 000000BE 0D 0A 00 
                       newline DCB              "\r\n\0"
 1007 000000C1 25 78 0D 
              0A 00    hex_str DCB              "%x\r\n\0"
 1008 000000C6         
 1009 000000C6         ;Variables
 1010 000000C6                 AREA             MyData,DATA,READWRITE
 1011 00000000         ;>>>>> begin variables here <<<<<
 1012 00000000 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00       number_1
                               SPACE            WORD_COUNT*4
 1013 00000010 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00       number_2
                               SPACE            WORD_COUNT*4
 1014 00000020 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00       result  SPACE            WORD_COUNT*4
 1015 00000030 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    printf_static
                               SPACE            20          ; Internal memory u
                                                            sed by printf
 1016 00000044         ;>>>>>   end variables here <<<<<



ARM Macro Assembler    Page 25 Program Title for Listing Header Goes Here


 1017 00000044                 ALIGN
 1018 00000044                 END
Command Line: --debug --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --
depend=.\objects\exercise08.d -o.\objects\exercise08.o -I"C:\Users\Andrei Tumba
r\AppData\Local\Arm\Packs\Keil\Kinetis_KLxx_DFP\1.14.0\Device\Include" -IC:\Kei
l_v5\ARM\CMSIS\Include --predefine="__EVAL SETA 1" --predefine="__UVISION_VERSI
ON SETA 531" --predefine="MKL05Z32xxx4 SETA 1" --list=.\listings\exercise08.lst
 Exercise08.s
