


ARM Macro Assembler    Page 1 Program Title for Listing Header Goes Here


    1 00000000                 TTL              Program Title for Listing Heade
r Goes Here
    2 00000000         ;*******************************************************
                       *********
    3 00000000         ;Descriptive comment header goes here.
    4 00000000         ;Serial I/O driver
    5 00000000         ;Name:  Andrei Tumbar
    6 00000000         ;Date:  10/07/20
    7 00000000         ;Class:  CMPE-250
    8 00000000         ;Section:  5, Tuesday, 11 AM
    9 00000000         ;-------------------------------------------------------
                       --------
   10 00000000         ;Keil Template for KL05
   11 00000000         ;R. W. Melton
   12 00000000         ;September 13, 2020
   13 00000000         ;*******************************************************
                       *********
   14 00000000         ;Assembler directives
   15 00000000                 THUMB
   17 00000000         ;*******************************************************
                       *********
   18 00000000         ;Include files
   19 00000000                 GET              MKL05Z4.s   ;Included by start.
                                                            s
   21 00000000         ;*******************************************************
                       *********
   22 00000000         ;-------------------------------------------------------
                       --------
   23 00000000         ;NVIC_ICER
   24 00000000         ;31-00:CLRENA=masks for HW IRQ sources;
   25 00000000         ;             read:   0 = unmasked;   1 = masked
   26 00000000         ;             write:  0 = no effect;  1 = mask
   27 00000000         ;12:UART0 IRQ mask
   28 00000000 00001000 
                       NVIC_ICER_UART0_MASK
                               EQU              UART0_IRQ_MASK
   29 00000000         ;-------------------------------------------------------
                       --------
   30 00000000         ;NVIC_ICPR
   31 00000000         ;31-00:CLRPEND=pending status for HW IRQ sources;
   32 00000000         ;             read:   0 = not pending;  1 = pending
   33 00000000         ;             write:  0 = no effect;
   34 00000000         ;                     1 = change status to not pending
   35 00000000         ;12:UART0 IRQ pending status
   36 00000000 00001000 
                       NVIC_ICPR_UART0_MASK
                               EQU              UART0_IRQ_MASK
   37 00000000         ;-------------------------------------------------------
                       --------
   38 00000000         ;NVIC_ISER
   39 00000000         ;31-00:SETENA=masks for HW IRQ sources;
   40 00000000         ;             read:   0 = masked;     1 = unmasked
   41 00000000         ;             write:  0 = no effect;  1 = unmask
   42 00000000         ;12:UART0 IRQ mask
   43 00000000 00001000 
                       NVIC_ISER_UART0_MASK
                               EQU              UART0_IRQ_MASK
   44 00000000         ;-------------------------------------------------------
                       --------



ARM Macro Assembler    Page 2 Program Title for Listing Header Goes Here


   45 00000000         ;NVIC_IPR0-NVIC_IPR7
   46 00000000         ;2-bit priority:  00 = highest; 11 = lowest
   47 00000000 00000003 
                       UART0_IRQ_PRIORITY
                               EQU              3
   48 00000000 000000C0 
                       NVIC_IPR_UART0_MASK
                               EQU              (3 << UART0_PRI_POS)
   49 00000000 000000C0 
                       NVIC_IPR_UART0_PRI_3
                               EQU              (UART0_IRQ_PRIORITY << UART0_PR
I_POS)
   50 00000000         ;-------------------------------------------------------
                       --------
   51 00000000         ;-------------------------------------------------------
                       --------
   52 00000000         ;PORTx_PCRn (Port x pin control register n [for pin n])
   53 00000000         ;___->10-08:Pin mux control (select 0 to 8)
   54 00000000         ;Use provided PORT_PCR_MUX_SELECT_2_MASK
   55 00000000         ;-------------------------------------------------------
                       --------
   56 00000000         ;SIM_SCGC4
   57 00000000         ;1->10:UART0 clock gate control (enabled)
   58 00000000         ;Use provided SIM_SCGC4_UART0_MASK
   59 00000000         ;-------------------------------------------------------
                       --------
   60 00000000         ;UART0_BDH
   61 00000000         ;    0->  7:LIN break detect IE (disabled)
   62 00000000         ;    0->  6:RxD input active edge IE (disabled)
   63 00000000         ;    0->  5:Stop bit number select (1)
   64 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)]) 
   65 00000000         ;UART0CLK is MCGFLLCLK
   66 00000000         ;MCGFLLCLK is 47972352 Hz ~=~ 48 MHz
   67 00000000         ;SBR ~=~ 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   68 00000000         ;SBR = 47972352 / (9600 * 16) = 312.32 --> 312 = 0x138
   69 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
   70 00000000         ;-------------------------------------------------------
                       --------
   71 00000000         ;UART0_BDL
   72 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
   73 00000000         ;UART0CLK is MCGFLLCLK
   74 00000000         ;MCGFLLCLK is 47972352 Hz ~=~ 48 MHz
   75 00000000         ;SBR ~=~ 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   76 00000000         ;SBR = 47972352 / (9600 * 16) = 312.32 --> 312 = 0x138
   77 00000000 00000038 
                       UART0_BDL_9600
                               EQU              0x38
   78 00000000         ;-------------------------------------------------------
                       --------
   79 00000000         ;UART0_C1
   80 00000000         ;0-->7:LOOPS=loops select (normal)
   81 00000000         ;0-->6:DOZEEN=doze enable (disabled)
   82 00000000         ;0-->5:RSRC=receiver source select (internal--no effect 
                       LOOPS=0)
   83 00000000         ;0-->4:M=9- or 8-bit mode select 
   84 00000000         ;        (1 start, 8 data [lsb first], 1 stop)
   85 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)



ARM Macro Assembler    Page 3 Program Title for Listing Header Goes Here


   86 00000000         ;0-->2:IDLE=idle line type select (idle begins after sta
                       rt bit)
   87 00000000         ;0-->1:PE=parity enable (disabled)
   88 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
   89 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
   90 00000000         ;-------------------------------------------------------
                       --------
   91 00000000         ;UART0_C2
   92 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
   93 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
   94 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
   95 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
   96 00000000         ;1-->3:TE=transmitter enable (enabled)
   97 00000000         ;1-->2:RE=receiver enable (enabled)
   98 00000000         ;0-->1:RWU=receiver wakeup control (normal)
   99 00000000         ;0-->0:SBK=send break (disabled, normal)
  100 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2
_RE_MASK)
  101 00000000 0000002C 
                       UART0_C2_T_RI
                               EQU              (UART0_C2_RIE_MASK :OR: UART0_C
2_T_R)
  102 00000000 000000AC 
                       UART0_C2_TI_RI
                               EQU              (UART0_C2_TIE_MASK :OR: UART0_C
2_T_RI)
  103 00000000         ;-------------------------------------------------------
                       --------
  104 00000000         ;UART0_C3
  105 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
  106 00000000         ;           10th data bit for transmitter (not used M10=
                       0)
  107 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
  108 00000000         ;           10th data bit for receiver (not used M10=0)
  109 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
  110 00000000         ;            (no effect LOOPS=0)
  111 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
  112 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
  113 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
  114 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
  115 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
  116 00000000 00000000 
                       UART0_C3_NO_TXINV
                               EQU              0x00
  117 00000000         ;-------------------------------------------------------
                       --------
  118 00000000         ;UART0_C4
  119 00000000         ;    0-->  7:MAEN1=match address mode enable 1 (disabled
                       )
  120 00000000         ;    0-->  6:MAEN2=match address mode enable 2 (disabled
                       )
  121 00000000         ;    0-->  5:M10=10-bit mode select (not selected)
  122 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
  123 00000000         ;               = 1 + OSR for 3 <= OSR <= 31
  124 00000000         ;               = 16 for 0 <= OSR <= 2 (invalid values)



ARM Macro Assembler    Page 4 Program Title for Listing Header Goes Here


  125 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
  126 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
  127 00000000         ;-------------------------------------------------------
                       --------
  128 00000000         ;UART0_C5
  129 00000000         ;  0-->  7:TDMAE=transmitter DMA enable (disabled)
  130 00000000         ;  0-->  6:Reserved; read-only; always 0
  131 00000000         ;  0-->  5:RDMAE=receiver full DMA enable (disabled)
  132 00000000         ;000-->4-2:Reserved; read-only; always 0
  133 00000000         ;  0-->  1:BOTHEDGE=both edge sampling (rising edge only
                       )
  134 00000000         ;  0-->  0:RESYNCDIS=resynchronization disable (enabled)
                       
  135 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  136 00000000         ;-------------------------------------------------------
                       --------
  137 00000000         ;UART0_S1
  138 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
                       
  139 00000000         ;0-->6:TC=transmission complete flag; read-only
  140 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  141 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  142 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear
                       )
  143 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  144 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  145 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  150 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              (UART0_S1_IDLE_MASK :OR:      
                        UART0_S1_OR_MASK :OR:                              UAR
T0_S1_NF_MASK :OR:                              UART0_S1_FE_MASK :OR:        
                      UART0_S1_PF_MASK)
  151 00000000         ;-------------------------------------------------------
                       --------
  152 00000000         ;UART0_S2
  153 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  154 00000000         ;             write 1 to clear
  155 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear
                       )
  156 00000000         ;              write 1 to clear
  157 00000000         ;0-->5:(reserved); read-only; always 0
  158 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  159 00000000         ;0-->3:RWUID=receive wake-up idle detect
  160 00000000         ;0-->2:BRK13=break character generation length (10)
  161 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  162 00000000         ;0-->0:RAF=receiver active flag; read-only
  164 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              (UART0_S2_LBKDIF_MASK :OR: UART
0_S2_RXEDGIF_MASK)
  165 00000000         ;-------------------------------------------------------
                       --------



ARM Macro Assembler    Page 5 Program Title for Listing Header Goes Here


  166 00000000         ;*******************************************************
                       *********
  167 00000000         ;EQUates
  168 00000000         ; Queue management record field offsets
  169 00000000 00000000 
                       IN_PTR  EQU              0
  170 00000000 00000004 
                       OUT_PTR EQU              4
  171 00000000 00000008 
                       BUF_STRT
                               EQU              8
  172 00000000 0000000C 
                       BUF_PAST
                               EQU              12
  173 00000000 00000010 
                       BUF_SIZE
                               EQU              16
  174 00000000 00000011 
                       NUM_ENQD
                               EQU              17
  175 00000000         ; Queue structure sizes
  176 00000000 00000004 
                       Q_BUF_SZ
                               EQU              4           ;Queue contents
  177 00000000 00000012 
                       Q_REC_SZ
                               EQU              18          ;Queue management r
                                                            ecord
  178 00000000 00000050 
                       X_BUF_SZ
                               EQU              80          ; Queue buffer size
                                                             for RxBuffer and T
                                                            xBuffer
  179 00000000         
  180 00000000         
  181 00000000                 MACRO
  182 00000000         $label  PUSH_STATUS      $RBUF, $R
  183 00000000                 LDRB             $RBUF,[$R,#NUM_ENQD]
  184 00000000                 PUSH             {$RBUF}
  185 00000000                 LDR              $RBUF,[$R,#OUT_PTR]
  186 00000000                 PUSH             {$RBUF}
  187 00000000                 LDR              $RBUF,[$R,#IN_PTR]
  188 00000000                 PUSH             {$RBUF}
  189 00000000                 MEND
  190 00000000         
  191 00000000                 MACRO
  192 00000000         $label  P                $string
  193 00000000                 PUSH             {R1}
  194 00000000                 LDR              R1,=$string
  195 00000000                 BL               printf
  196 00000000                 POP              {R1}
  197 00000000                 MEND
  198 00000000         
  199 00000000         ;*******************************************************
                       *********
  200 00000000         ;Program
  201 00000000         ;Linker requires Reset_Handler
  202 00000000                 AREA             MyCode,CODE,READONLY
  203 00000000                 ENTRY



ARM Macro Assembler    Page 6 Program Title for Listing Header Goes Here


  204 00000000                 EXPORT           Reset_Handler
  205 00000000                 IMPORT           Startup
  206 00000000         Reset_Handler
                               PROC             {}
  207 00000000         main
  208 00000000         ;-------------------------------------------------------
                       --------
  209 00000000         ;Mask interrupts
  210 00000000 B672            CPSID            I
  211 00000002         ;KL05 system startup with 48-MHz system clock
  212 00000002 F7FF FFFE       BL               Startup
  213 00000006 F7FF FFFE       BL               Init_UART0_IRQ
  214 0000000A B662            CPSIE            I           ; Unmask interrupts
                                                            
  215 0000000C         ;-------------------------------------------------------
                       --------
  216 0000000C         ;>>>>> begin main program code <<<<<
  217 0000000C         ; Initialize a queue structure with
  218 0000000C         ; a 4-byte circular buffer
  219 0000000C 480D            LDR              R0,=buffer
  220 0000000E 490E            LDR              R1,=queue
  221 00000010 2204            MOVS             R2,#Q_BUF_SZ
  222 00000012 F7FF FFFE       BL               InitQueue
  223 00000016         
  224 00000016         __9     P                newline
  193 00000016 B402            PUSH             {R1}
  194 00000018 490C            LDR              R1,=newline
  195 0000001A F7FF FFFE       BL               printf
  196 0000001E BC02            POP              {R1}
  225 00000020         
  226 00000020         main_loop
  227 00000020         __0     P                prompt      ; Print the prompt 
                                                            string
  193 00000020 B402            PUSH             {R1}
  194 00000022 490B            LDR              R1,=prompt
  195 00000024 F7FF FFFE       BL               printf
  196 00000028 BC02            POP              {R1}
  228 0000002A         ; Get input
  229 0000002A F7FF FFFE       BL               GetChar
  230 0000002E F7FF FFFE       BL               PutChar
  231 00000032         
  232 00000032         ; Print a newline and handle the inputed command
  233 00000032                 P                newline
  193 00000032 B402            PUSH             {R1}
  194 00000034 4905            LDR              R1,=newline
  195 00000036 F7FF FFFE       BL               printf
  196 0000003A BC02            POP              {R1}
  234 0000003C F7FF FFFE       BL               HandleCommand
  235 00000040         
  236 00000040 E7EE            B                main_loop
  237 00000042         
  238 00000042         ;>>>>>   end main program code <<<<<
  239 00000042         ;Stay here
  240 00000042 E7FE            B                .
  241 00000044                 ENDP
  242 00000044                 ALIGN
  243 00000044 00000000 
              00000000 
              00000000 



ARM Macro Assembler    Page 7 Program Title for Listing Header Goes Here


              00000000 
              00000000         LTORG
  244 00000058         
  245 00000058         ; Handle a command input
  246 00000058         ; Subroutines used:
  247 00000058         ;   Dequene
  248 00000058         ;   Enqueue
  249 00000058         ;   printf
  250 00000058         ;   PutChar
  251 00000058         ; Input:
  252 00000058         ;   R0: input command (case insensitive)
  253 00000058         ;   R1: Pointer to queue structure
  254 00000058         ; Output (None)
  255 00000058         ; Modified Registers (None)
  256 00000058         HandleCommand
                               PROC             {R0-R12}
  257 00000058 B51F            PUSH             {R0-R4,LR}
  258 0000005A 00000061 
                       AS_L_S  EQU              'a'
  259 0000005A 0000007A 
                       AS_L_E  EQU              'z'
  260 0000005A 00000041 
                       AS_U_S  EQU              'A'
  261 0000005A 0000005A 
                       AS_U_E  EQU              'Z'
  262 0000005A         
  263 0000005A         ; Convert the character to upper-case
  264 0000005A 2841            CMP              R0,#AS_U_S
  265 0000005C DB4A            BLT              invalid_char
  266 0000005E 285A            CMP              R0,#AS_U_E
  267 00000060 DD01            BLE              do_cmd      ; Already in upperc
                                                            ase
  268 00000062         ; Convert to upper case
  269 00000062 3820            SUBS             R0,R0,#(AS_L_S - AS_U_S)
  270 00000064 E7FF            B                do_cmd
  271 00000066         
  272 00000066 2844    do_cmd  CMP              R0,#'D'
  273 00000068 D008            BEQ              do_deq
  274 0000006A 2845            CMP              R0,#'E'
  275 0000006C D00C            BEQ              do_enq
  276 0000006E 2848            CMP              R0,#'H'
  277 00000070 D03C            BEQ              do_help
  278 00000072 2850            CMP              R0,#'P'
  279 00000074 D01A            BEQ              do_print
  280 00000076 2853            CMP              R0,#'S'
  281 00000078 D032            BEQ              do_status
  282 0000007A E03B            B                invalid_char
  283 0000007C         
  284 0000007C F7FF FFFE 
                       do_deq  BL               Dequeue
  285 00000080 D245            BCS              handle_fail
  286 00000082 F7FF FFFE       BL               PutChar
  287 00000086 E048            B                print_status
  288 00000088         
  289 00000088         do_enq                               ; Print the enqueue
                                                             prompt
  290 00000088         __1     P                prompt_en
  193 00000088 B402            PUSH             {R1}
  194 0000008A 49ED            LDR              R1,=prompt_en



ARM Macro Assembler    Page 8 Program Title for Listing Header Goes Here


  195 0000008C F7FF FFFE       BL               printf
  196 00000090 BC02            POP              {R1}
  291 00000092         
  292 00000092         ; Get the character and enqueue it
  293 00000092 F7FF FFFE       BL               GetChar
  294 00000096 F7FF FFFE       BL               PutChar
  295 0000009A         __8     P                newline
  193 0000009A B402            PUSH             {R1}
  194 0000009C 49E9            LDR              R1,=newline
  195 0000009E F7FF FFFE       BL               printf
  196 000000A2 BC02            POP              {R1}
  296 000000A4         
  297 000000A4 F7FF FFFE       BL               Enqueue
  298 000000A8 D231            BCS              handle_fail
  299 000000AA E02A            B                handle_info
  300 000000AC         
  301 000000AC         do_print                             ; Print the content
                                                            s of the queue
  302 000000AC 203E            MOVS             R0,#'>'
  303 000000AE F7FF FFFE       BL               PutChar
  304 000000B2 684A            LDR              R2,[R1,#OUT_PTR]
  305 000000B4 7C4B            LDRB             R3,[R1,#NUM_ENQD]
  306 000000B6 68CC            LDR              R4,[R1,#BUF_PAST]
  307 000000B8 421B    do_print_l
                               TST              R3,R3       ; While we have not
                                                             printed all of the
                                                             characters
  308 000000BA D008            BEQ              do_print_b  ; break
  309 000000BC 7810            LDRB             R0,[R2,#0]  ; Print this charac
                                                            ter
  310 000000BE F7FF FFFE       BL               PutChar
  311 000000C2 1C52            ADDS             R2,R2,#1    ; Increment the poi
                                                            nter
  312 000000C4 1E5B            SUBS             R3,R3,#1    ; Decrement the dow
                                                            n counter
  313 000000C6 42A2            CMP              R2,R4       ; Check if we need 
                                                            to circle back
  314 000000C8 DBF6            BLT              do_print_l
  315 000000CA 688A            LDR              R2,[R1,#BUF_STRT] ; Circle back
                                                             to the start of th
                                                            e buffer
  316 000000CC E7F4            B                do_print_l
  317 000000CE 203C    do_print_b
                               MOVS             R0,#'<'
  318 000000D0 F7FF FFFE       BL               PutChar
  319 000000D4                 P                newline
  193 000000D4 B402            PUSH             {R1}
  194 000000D6 49DB            LDR              R1,=newline
  195 000000D8 F7FF FFFE       BL               printf
  196 000000DC BC02            POP              {R1}
  320 000000DE E025            B                end_handle
  321 000000E0         
  322 000000E0         do_status
  323 000000E0         __7     P                status_s
  193 000000E0 B402            PUSH             {R1}
  194 000000E2 49D9            LDR              R1,=status_s
  195 000000E4 F7FF FFFE       BL               printf
  196 000000E8 BC02            POP              {R1}
  324 000000EA E016            B                print_status



ARM Macro Assembler    Page 9 Program Title for Listing Header Goes Here


  325 000000EC         
  326 000000EC 49D7    do_help LDR              R1,=help
  327 000000EE F7FF FFFE       BL               printf
  328 000000F2 E01B            B                end_handle
  329 000000F4         
  330 000000F4         invalid_char
  331 000000F4 B402            PUSH             {R1}
  332 000000F6 B401            PUSH             {R0}
  333 000000F8 49D5            LDR              R1,=invalid_in
  334 000000FA F7FF FFFE 
                       __6     BL               printf
  335 000000FE BC02            POP              {R1}
  336 00000100 E014            B                end_handle
  337 00000102         
  338 00000102         handle_info
  339 00000102         __4     P                success
  193 00000102 B402            PUSH             {R1}
  194 00000104 49D3            LDR              R1,=success
  195 00000106 F7FF FFFE       BL               printf
  196 0000010A BC02            POP              {R1}
  340 0000010C E005            B                print_status
  341 0000010E         handle_fail
  342 0000010E         __3     P                failure
  193 0000010E B402            PUSH             {R1}
  194 00000110 49D1            LDR              R1,=failure
  195 00000112 F7FF FFFE       BL               printf
  196 00000116 BC02            POP              {R1}
  343 00000118 E7FF            B                print_status
  344 0000011A         print_status
  345 0000011A         __2     PUSH_STATUS      R0,R1
  183 0000011A 7C48            LDRB             R0,[R1,#NUM_ENQD]
  184 0000011C B401            PUSH             {R0}
  185 0000011E 6848            LDR              R0,[R1,#OUT_PTR]
  186 00000120 B401            PUSH             {R0}
  187 00000122 6808            LDR              R0,[R1,#IN_PTR]
  188 00000124 B401            PUSH             {R0}
  346 00000126 49CD            LDR              R1,=status
  347 00000128 F7FF FFFE 
                       __5     BL               printf
  348 0000012C BD1F    end_handle
                               POP              {R0-R4,PC}
  349 0000012E                 ENDP
  350 0000012E         
  351 0000012E         ;>>>>> begin subroutine code <<<<<
  352 0000012E         ; This subroutine is a printf() clone with the following
                       
  353 0000012E         ; formats defined:
  354 0000012E         ;    %x: hex
  355 0000012E         ;    %d: decimal
  356 0000012E         ;    %s: string
  357 0000012E         ;    %b: single byte decimal
  358 0000012E         ;    %c: char
  359 0000012E         ; Subroutines used:
  360 0000012E         ;    PutChar
  361 0000012E         ;    PutNumHex (%x)
  362 0000012E         ;    PutNumU   (%d)
  363 0000012E         ;    PutStringSB (%s)
  364 0000012E         ;    PutNumUB (%b)
  365 0000012E         ;    printf (recursive call on error)



ARM Macro Assembler    Page 10 Program Title for Listing Header Goes Here


  366 0000012E         ; Input Registers:
  367 0000012E         ;    R1: Pointer to the format string
  368 0000012E         ;    N variables on the stack that correspond 
  369 0000012E         ;    to arguments in the format string
  370 0000012E         ; Output (None)
  371 0000012E         ; Modified Registers (None)
  372 0000012E         printf  PROC             {R0-R12}
  373 0000012E         ; Because the stack is used to pass parameters to
  374 0000012E         ; this subroutines. We can't modify the stack pointer
  375 0000012E         ; before moving through the format string.
  376 0000012E         ; Use the memory as a stack
  377 0000012E B420            PUSH             {R5}
  378 00000130 4DCB            LDR              R5,=printf_static
  379 00000132 6028            STR              R0,[R5,#0]
  380 00000134 6069            STR              R1,[R5,#4]
  381 00000136 60AA            STR              R2,[R5,#8]
  382 00000138 60EB            STR              R3,[R5,#12]
  383 0000013A 612C            STR              R4,[R5,#16]
  384 0000013C BC20            POP              {R5}
  385 0000013E         
  386 0000013E         ; Store the return pointer
  387 0000013E B500            PUSH             {LR}
  388 00000140 BC10            POP              {R4}
  389 00000142         
  390 00000142 780A    printf_loop
                               LDRB             R2,[R1,#0]
  391 00000144 4212            TST              R2,R2
  392 00000146 D032            BEQ              printf_end  ;  End of string
  393 00000148 2A25            CMP              R2,#'%'     ; Format character
  394 0000014A D003            BEQ              printf_fmt
  395 0000014C 0010            MOVS             R0,R2
  396 0000014E F7FF FFFE       BL               PutChar
  397 00000152 E02A            B                printf_continue
  398 00000154 1C49    printf_fmt
                               ADDS             R1,R1,#1
  399 00000156 780A            LDRB             R2,[R1,#0]
  400 00000158 2A78            CMP              R2,#'x'     ; Print a hex strin
                                                            g
  401 0000015A D00F            BEQ              printf_h
  402 0000015C 2A64            CMP              R2,#'d'     ; Print a decimal s
                                                            tring
  403 0000015E D011            BEQ              printf_d
  404 00000160 2A73            CMP              R2,#'s'     ; Print a string
  405 00000162 D013            BEQ              printf_s
  406 00000164 2A63            CMP              R2,#'c'
  407 00000166 D01C            BEQ              printf_c
  408 00000168 2A62            CMP              R2,#'b'     ; Print a single by
                                                            te
  409 0000016A D016            BEQ              printf_b
  410 0000016C         ; INVALID FORMAT STRING
  411 0000016C         ; Print the error string
  412 0000016C B420            PUSH             {R5}
  413 0000016E 6869            LDR              R1,[R5,#4]
  414 00000170 BC20            POP              {R5}
  415 00000172         
  416 00000172 B402            PUSH             {R1}
  417 00000174 49BB            LDR              R1,=invalid
  418 00000176 F7FF FFFE       BL               printf
  419 0000017A E7FE            B                .           ; Invalid format st



ARM Macro Assembler    Page 11 Program Title for Listing Header Goes Here


                                                            ring (STOP)
  420 0000017C         printf_h                             ; Print the current
                                                             number in R0
  421 0000017C BC01            POP              {R0}
  422 0000017E F7FF FFFE       BL               PutNumHex
  423 00000182 E012            B                printf_continue
  424 00000184         printf_d                             ; Print the current
                                                             digit in R0
  425 00000184 BC01            POP              {R0}
  426 00000186 F7FF FFFE       BL               PutNumU
  427 0000018A E00E            B                printf_continue
  428 0000018C         printf_s                             ; Print the string 
                                                            in R0
  429 0000018C BC01            POP              {R0}
  430 0000018E B402            PUSH             {R1}
  431 00000190 2164            MOVS             R1,#100     ; Max string length
                                                             of 100
  432 00000192 F7FF FFFE       BL               PutStringSB
  433 00000196 BC02            POP              {R1}
  434 00000198 E007            B                printf_continue
  435 0000019A         printf_b                             ; Print the single 
                                                            byte value in R0
  436 0000019A BC01            POP              {R0}
  437 0000019C F7FF FFFE       BL               PutNumUB
  438 000001A0 E003            B                printf_continue
  439 000001A2         printf_c                             ; Print the single 
                                                            char value in R0
  440 000001A2 BC01            POP              {R0}
  441 000001A4 F7FF FFFE       BL               PutChar
  442 000001A8 E7FF            B                printf_continue
  443 000001AA 1C49    printf_continue
                               ADDS             R1,R1,#1
  444 000001AC E7C9            B                printf_loop
  445 000001AE         printf_end                           ; Restore the link 
                                                            register
  446 000001AE B410            PUSH             {R4}        ; This will be POP'
                                                            ed to PC
  447 000001B0         
  448 000001B0         ; Restore registers from memory
  449 000001B0 B420            PUSH             {R5}
  450 000001B2 4DAB            LDR              R5,=printf_static
  451 000001B4 6828            LDR              R0,[R5,#0]
  452 000001B6 6869            LDR              R1,[R5,#4]
  453 000001B8 68AA            LDR              R2,[R5,#8]
  454 000001BA 68EB            LDR              R3,[R5,#12]
  455 000001BC 692C            LDR              R4,[R5,#16]
  456 000001BE BC20            POP              {R5}
  457 000001C0         
  458 000001C0 BD00            POP              {PC}
  459 000001C2                 ENDP
  460 000001C2         
  461 000001C2         ; Initialize a queue structure
  462 000001C2         ; Subroutines Used: (none)
  463 000001C2         ; Input:
  464 000001C2         ;   R0: Pointer to the first address of the circular buf
                       fer
  465 000001C2         ;   R1: Pointer to the start of the queue structure
  466 000001C2         ;   R2: Size of the circular buffer pointed to by R0
  467 000001C2         ; Output (None)



ARM Macro Assembler    Page 12 Program Title for Listing Header Goes Here


  468 000001C2         ; Modified Registers (None)
  469 000001C2         InitQueue
                               PROC             {R0-R12}
  470 000001C2 B407            PUSH             {R0-R2}
  471 000001C4 6008            STR              R0,[R1,#IN_PTR]
  472 000001C6 6048            STR              R0,[R1,#OUT_PTR]
  473 000001C8 6088            STR              R0,[R1,#BUF_STRT]
  474 000001CA 1880            ADDS             R0,R0,R2
  475 000001CC 60C8            STR              R0,[R1,#BUF_PAST]
  476 000001CE 740A            STRB             R2,[R1,#BUF_SIZE]
  477 000001D0 2000            MOVS             R0,#0
  478 000001D2 7448            STRB             R0,[R1,#NUM_ENQD]
  479 000001D4 BC07            POP              {R0-R2}
  480 000001D6 4770            BX               LR
  481 000001D8                 ENDP
  482 000001D8         
  483 000001D8         ; Emplace a character into the queue structure.
  484 000001D8         ; If the queue is already full, indicate failure
  485 000001D8         ; by setting the C flag in the APSR. A cleared C flag
  486 000001D8         ; indicates success.
  487 000001D8         ; Subroutes used: (none)
  488 000001D8         ; Input:  R0:  Character to enqueue
  489 000001D8         ;         R1:  Address of queue record structure
  490 000001D8         ; Output:  PSR C flag:  Success(0) or Failure (1)
  491 000001D8         ; Modify:  APSR
  492 000001D8         ; All other registers remain unchanged on return
  493 000001D8         Enqueue PROC             {R0-R12}
  494 000001D8 B40C            PUSH             {R2,R3}
  495 000001DA 7C4A            LDRB             R2,[R1,#NUM_ENQD]
  496 000001DC 7C0B            LDRB             R3,[R1,#BUF_SIZE]
  497 000001DE 429A            CMP              R2,R3       ; Check if the queu
                                                            e is full
  498 000001E0 DA11            BGE              en_full
  499 000001E2 680B            LDR              R3,[R1,#IN_PTR]
  500 000001E4 7018            STRB             R0,[R3,#0]  ; Put new element a
                                                            t memory location p
                                                            ointed by InPointer
                                                            
  501 000001E6         ; Increment NumberEnqueued
  502 000001E6 1C52            ADDS             R2,R2,#1
  503 000001E8 744A            STRB             R2,[R1,#NUM_ENQD]
  504 000001EA         
  505 000001EA         ; Increment InPointer
  506 000001EA 1C5B            ADDS             R3,R3,#1
  507 000001EC 68CA            LDR              R2,[R1,#BUF_PAST]
  508 000001EE 4293            CMP              R3,R2
  509 000001F0 DB00            BLT              en_str      ; If (R1->in_ptr < 
                                                            R1->BUF_PAST) goto 
                                                            en_str
  510 000001F2         ; IN_PTR is past the end of the queue
  511 000001F2         ; We need to set it back to the start of the queue
  512 000001F2 688B            LDR              R3,[R1,#BUF_STRT]
  513 000001F4 600B    en_str  STR              R3,[R1,#IN_PTR]
  514 000001F6         ; Clear the carry flag  (No error occured)
  515 000001F6 F3EF 8200       MRS              R2,APSR
  516 000001FA 2320            MOVS             R3,#0x20
  517 000001FC 061B            LSLS             R3,R3,#24
  518 000001FE 439A            BICS             R2,R2,R3
  519 00000200 F382 8800       MSR              APSR,R2



ARM Macro Assembler    Page 13 Program Title for Listing Header Goes Here


  520 00000204 E006            B                en_done     ; Don't clear the A
                                                            PSR C-flag
  521 00000206         en_full                              ; Set the carry fla
                                                            g  (Error occured)
  522 00000206 F3EF 8200       MRS              R2,APSR
  523 0000020A 2320            MOVS             R3,#0x20
  524 0000020C 061B            LSLS             R3,R3,#24
  525 0000020E 431A            ORRS             R2,R2,R3
  526 00000210 F382 8800       MSR              APSR,R2
  527 00000214 BC0C    en_done POP              {R2,R3}
  528 00000216 4770            BX               LR
  529 00000218                 ENDP
  530 00000218         
  531 00000218         ; Remove the next item from the queue structure.
  532 00000218         ; If the queue is already empty, indicate failure by
  533 00000218         ; setting the C flag in the APSR. A cleared C flag
  534 00000218         ; indicates success.
  535 00000218         ; Subroutines used: (none)
  536 00000218         ; Input:  R1:  Address of queue record structure 
  537 00000218         ; Output: R0:  Character dequeued 
  538 00000218         ;         PSR C flag:  Success(0) or Failure (1)
  539 00000218         ; Modify: R0
  540 00000218         ; APSR 
  541 00000218         ; All other registers remain unchanged on return
  542 00000218         Dequeue PROC             {R1-R12}
  543 00000218 B41C            PUSH             {R2-R4}
  544 0000021A 7C4A            LDRB             R2,[R1,#NUM_ENQD] 
                                                            ; R2 = NUM_ENQ
  545 0000021C 684B            LDR              R3,[R1,#OUT_PTR] ; R3 = OUT_PTR
                                                            
  546 0000021E 2A00            CMP              R2,#0
  547 00000220 DD10            BLE              de_empty    ; No more items in 
                                                            the queue
  548 00000222 7818            LDRB             R0,[R3,#0]  ; Get item at OUT_P
                                                            TR
  549 00000224         ; Decrement number enqueued
  550 00000224 1E52            SUBS             R2,R2,#1
  551 00000226 744A            STRB             R2,[R1,#NUM_ENQD]
  552 00000228         
  553 00000228         ; Increment OutPointer
  554 00000228 1C5B            ADDS             R3,R3,#1
  555 0000022A 68CC            LDR              R4,[R1,#BUF_PAST]
  556 0000022C 42A3            CMP              R3,R4
  557 0000022E DB00            BLT              de_str      ; If (R1->out_ptr <
                                                             R1->BUF_PAST) goto
                                                             de_str
  558 00000230         ; OUT_PTR is past the end of the queue
  559 00000230         ; We need to set it back to the start of the queue
  560 00000230 688B            LDR              R3,[R1,#BUF_STRT]
  561 00000232 604B    de_str  STR              R3,[R1,#OUT_PTR]
  562 00000234         ; Clear the carry flag (No error occured)
  563 00000234 F3EF 8200       MRS              R2,APSR
  564 00000238 2320            MOVS             R3,#0x20
  565 0000023A 061B            LSLS             R3,R3,#24
  566 0000023C 439A            BICS             R2,R2,R3
  567 0000023E F382 8800       MSR              APSR,R2
  568 00000242 E006            B                de_done
  569 00000244         de_empty                             ; Set the carry fla
                                                            g (Error occured)



ARM Macro Assembler    Page 14 Program Title for Listing Header Goes Here


  570 00000244 F3EF 8200       MRS              R2,APSR
  571 00000248 2320            MOVS             R3,#0x20
  572 0000024A 061B            LSLS             R3,R3,#24
  573 0000024C 431A            ORRS             R2,R2,R3
  574 0000024E F382 8800       MSR              APSR,R2
  575 00000252 BC1C    de_done POP              {R2-R4}
  576 00000254 4770            BX               LR
  577 00000256                 ENDP
  578 00000256         
  579 00000256         
  580 00000256         ; Print a 32-bit number in hex
  581 00000256         ; Subroutines used:
  582 00000256         ;   PutDigHex
  583 00000256         ; Input parameter:
  584 00000256         ;   R0: number to print in hexadecimal (unsigned word va
                       lue)
  585 00000256         ; Output parameter: (none)
  586 00000256         PutNumHex
                               PROC             {R0-R12}
  587 00000256 0000000F 
                       RIGHT_NIBBLE_MASK
                               EQU              0x0F
  588 00000256 B51F            PUSH             {R0-R4,LR}
  589 00000258         ; There are 4 bytes to print
  590 00000258 2100            MOVS             R1,#0       ; Use R1 as an iter
                                                            ator
  591 0000025A 2318            MOVS             R3,#24
  592 0000025C 240F            MOVS             R4,#RIGHT_NIBBLE_MASK
  593 0000025E 41D8            RORS             R0,R0,R3    ; Move the MSB to t
                                                            he LSB
  594 00000260 2904    pnh_loop
                               CMP              R1,#4
  595 00000262 DA0A            BGE              pnh_done
  596 00000264         ; Print the most significant nibble
  597 00000264 0902            LSRS             R2,R0,#4
  598 00000266 4022            ANDS             R2,R2,R4
  599 00000268 F7FF FFFE       BL               PutDigHex   ; Print this digit
  600 0000026C         ; Print the least significant nibble
  601 0000026C 0002            MOVS             R2,R0
  602 0000026E 4022            ANDS             R2,R2,R4
  603 00000270 F7FF FFFE       BL               PutDigHex
  604 00000274 41D8            RORS             R0,R0,R3    ; Move to the next 
                                                            byte
  605 00000276 1C49            ADDS             R1,R1,#1    ; i++
  606 00000278 E7F2            B                pnh_loop
  607 0000027A BD1F    pnh_done
                               POP              {R0-R4,PC}
  608 0000027C                 ENDP
  609 0000027C         
  610 0000027C         ; Print a single hex digit
  611 0000027C         ; stored in R2
  612 0000027C         ; Subroutines used:
  613 0000027C         ;   PutChar
  614 0000027C         ; Input parameter:
  615 0000027C         ;   R2 Hex digit to print
  616 0000027C         PutDigHex
                               PROC             {R0-R12}
  617 0000027C 0000000A 
                       ASCII_LETTER



ARM Macro Assembler    Page 15 Program Title for Listing Header Goes Here


                               EQU              10          ; Any values greate
                                                            r than or equal to 
                                                            this will be a lett
                                                            er A-F
  618 0000027C 00000030 
                       ASCII_DIG_OFF
                               EQU              '0'
  619 0000027C 00000039 
                       ASCII_DIG_LAST
                               EQU              '9'
  620 0000027C 00000007 
                       ASCII_LET_OFF
                               EQU              ('A' - '0' - 10)
  621 0000027C B50D            PUSH             {R0,R2,R3,LR}
  622 0000027E 23FF            MOVS             R3,#0xFF
  623 00000280 401A            ANDS             R2,R2,R3
  624 00000282 3230            ADDS             R2,#ASCII_DIG_OFF
  625 00000284 2A39            CMP              R2,#ASCII_DIG_LAST
  626 00000286 DB00            BLT              put_dig
  627 00000288 1DD2            ADDS             R2,R2,#ASCII_LET_OFF
  628 0000028A 0010    put_dig MOVS             R0,R2
  629 0000028C F7FF FFFE       BL               PutChar
  630 00000290 BD0D            POP              {R0,R2,R3,PC}
  631 00000292                 ENDP
  632 00000292         
  633 00000292         ; Prints to the terminal screen the decimal representati
                       on of the
  634 00000292         ; unsigned byte value in R0
  635 00000292         ; Subroutines Used:
  636 00000292         ;  PutNumU
  637 00000292         ; Input parameter:
  638 00000292         ;   R0:number to print in decimal (unsigned byte value)
  639 00000292         ;Output parameter: (none)
  640 00000292         PutNumUB
                               PROC             {R0-R12}
  641 00000292 B503            PUSH             {R0,R1,LR}
  642 00000294 21FF            MOVS             R1,#BYTE_MASK
  643 00000296 4008            ANDS             R0,R0,R1
  644 00000298 F7FF FFFE       BL               PutNumU
  645 0000029C BD03            POP              {R0,R1,PC}
  646 0000029E                 ENDP
  647 0000029E         
  648 0000029E         ; Print a number in decimal using the ascii
  649 0000029E         ; characters
  650 0000029E         ; SUBROUTINES USED
  651 0000029E         ;   - PutChar (Print each digit)
  652 0000029E         ;   - DIVU
  653 0000029E         ; PARAMS
  654 0000029E         ;   INPUT R0: Number to print (unsigned word value)
  655 0000029E         ;   OUTPUT  : NONE
  656 0000029E         PutNumU PROC             {R0-R12}
  657 0000029E B507            PUSH             {R0-R2,LR}
  658 000002A0 0000000A 
                       printbase
                               EQU              10
  659 000002A0 00000030 
                       asciioffset
                               EQU              '0'
  660 000002A0         ; put_num_u(U32 r0)



ARM Macro Assembler    Page 16 Program Title for Listing Header Goes Here


  661 000002A0         ; while (r0 != 0)
  662 000002A0         ;   (add r0 % 10 to stack)
  663 000002A0         ;   r0 /= 10
  664 000002A0         ; print the stack backwards
  665 000002A0 2800            CMP              R0,#0       ; Just print a '0'
  666 000002A2 D011            BEQ              numzero
  667 000002A4         
  668 000002A4 2200            MOVS             R2,#0       ; Count the number 
                                                            of digits
  669 000002A6 2800    numwhile
                               CMP              R0,#0       ; while (r0 != 0)
  670 000002A8 D005            BEQ              numwhile2
  671 000002AA 210A            MOVS             R1,#printbase ; Always divide b
                                                            y the base
  672 000002AC F7FF FFFE       BL               DIVU        ; R0 = R0 / base; R
                                                            0 % base
  673 000002B0 B402            PUSH             {R1}        ; Need to print the
                                                            se digits backwards
                                                            
  674 000002B2 1C52            ADDS             R2,R2,#1    ; r2++
  675 000002B4 E7F7            B                numwhile
  676 000002B6 2A01    numwhile2
                               CMP              R2,#1       ; while (r2 >= 1)
  677 000002B8 DB09            BLT              numdone
  678 000002BA BC02            POP              {R1}
  679 000002BC 0008            MOVS             R0,R1
  680 000002BE 3030            ADDS             R0,R0,#asciioffset ; Print the 
                                                            next character (asc
                                                            ii not just value)
  681 000002C0 1E52            SUBS             R2,R2,#1
  682 000002C2 F7FF FFFE       BL               PutChar
  683 000002C6 E7F6            B                numwhile2
  684 000002C8 2030    numzero MOVS             R0,#'0'
  685 000002CA F7FF FFFE       BL               PutChar
  686 000002CE BD07    numdone POP              {R0-R2,PC}
  687 000002D0                 ENDP
  688 000002D0         
  689 000002D0         ; Calculate the quotient and remainder of
  690 000002D0         ; two unsigned word values.
  691 000002D0         ; SUBROUTINES: None
  692 000002D0         ; PARAMS:
  693 000002D0         ;   INPUT R0: dividend (unsigned word)
  694 000002D0         ;   INPUT R1: divisor  (unsigned word)
  695 000002D0         ;   OUTPUT R0: quotient (unsigned word)
  696 000002D0         ;   OUTPUT R1: remainder (unsigned word)
  697 000002D0         DIVU    PROC             {R2-R12}
  698 000002D0 B500            PUSH             {LR}
  699 000002D2 B4FC            PUSH             {R2-R7}
  700 000002D4 2900            CMP              R1,#0
  701 000002D6 D01D            BEQ              DIVU_0      ; Don't try to divi
                                                            de by zero
  702 000002D8 00000080 
                       LEFT_MASK
                               EQU              0x80        ; Used to get most 
                                                            significant bit of 
                                                            a byte
  703 000002D8 0000001F 
                       SHIFT32 EQU              31
  704 000002D8         ; Compute N / D



ARM Macro Assembler    Page 17 Program Title for Listing Header Goes Here


  705 000002D8         ; Use binary long division
  706 000002D8         ; R = 0 (Use R2)
  707 000002D8         ; Q = 0 (Use R3)
  708 000002D8         ; for (i = 31; i >= 0; i--) {
  709 000002D8         ;   R = R << 1
  710 000002D8         ;   R |= (N & LEFT_MASK) >> 31
  711 000002D8         ;   N = N << 1
  712 000002D8         ;   if R >= D {
  713 000002D8         ;       R = R - D
  714 000002D8         ;       Q |= 1 << i
  715 000002D8         ;   }
  716 000002D8         ; }
  717 000002D8 2200            MOVS             R2,#0       ; Init Remainder
  718 000002DA 2300            MOVS             R3,#0       ; Init the Quotient
                                                            
  719 000002DC 241F            MOVS             R4,#SHIFT32 ; Init the iterator
                                                             (i)
  720 000002DE 2601            MOVS             R6,#1       ; Used for Q = Q | 
                                                            (1 << i)
  721 000002E0 2C00    DIV_FOR CMP              R4,#0       ; if (i >= 0)
  722 000002E2 DB0D            BLT              DIVU_FINISH ; Finished loop
  723 000002E4 0052            LSLS             R2,R2,#1    ; R = R << 1
  724 000002E6 0FC5            LSRS             R5,R0,#SHIFT32 ; R5 = most sign
                                                            ificant bit in N
  725 000002E8 2601            MOVS             R6,#1
  726 000002EA 4035            ANDS             R5,R5,R6    ; R5 = (N & LEFT_MA
                                                            SK) >> 31
  727 000002EC 432A            ORRS             R2,R2,R5    ; R |= (N & LEFT_MA
                                                            SK) >> 31
  728 000002EE 0040            LSLS             R0,R0,#1    ; N = N << 1
  729 000002F0 428A            CMP              R2,R1       ; if (R >= D)
  730 000002F2 D303            BLO              DIV_ITER    ; continue;
  731 000002F4 1A52            SUBS             R2,R2,R1    ; R = R - D
  732 000002F6 40A6            LSLS             R6,R6,R4    ; R6 = 1 << i
  733 000002F8 0035            MOVS             R5,R6
  734 000002FA 432B            ORRS             R3,R3,R5    ; Q = Q | (1 << i)
  735 000002FC 1E64    DIV_ITER
                               SUBS             R4,R4,#1    ; i--
  736 000002FE E7EF            B                DIV_FOR     ; For loop
  737 00000300 0018    DIVU_FINISH
                               MOVS             R0,R3       ; Set the outputs
  738 00000302 0011            MOVS             R1,R2       ;
  739 00000304         ; Clear the carry flag
  740 00000304 F3EF 8200       MRS              R2,APSR
  741 00000308 2320            MOVS             R3,#0x20
  742 0000030A 061B            LSLS             R3,R3,#24
  743 0000030C 439A            BICS             R2,R2,R3
  744 0000030E F382 8800       MSR              APSR,R2
  745 00000312 E007            B                DIVU_STOP
  746 00000314 2301    DIVU_0  MOVS             R3,#1       ; Init R3 as 1
  747 00000316         ; Set the carry flag
  748 00000316 F3EF 8200       MRS              R2,APSR
  749 0000031A 2320            MOVS             R3,#0x20
  750 0000031C 061B            LSLS             R3,R3,#24
  751 0000031E 431A            ORRS             R2,R2,R3
  752 00000320 F382 8800       MSR              APSR,R2
  753 00000324 BCFC    DIVU_STOP
                               POP              {R2-R7}
  754 00000326 BD00            POP              {PC}



ARM Macro Assembler    Page 18 Program Title for Listing Header Goes Here


  755 00000328                 ENDP
  756 00000328         
  757 00000328         
  758 00000328         ; PutChar will print a character to the terminal
  759 00000328         ; Subroutines used: Enqueue
  760 00000328         ; Input: R0 (character to print)
  761 00000328         ; Output; None
  762 00000328         ; Register modification list: R1-R3
  763 00000328         PutChar PROC             {R0-R12}
  764 00000328 B503            PUSH             {R0,R1,LR}
  765 0000032A 494F            LDR              R1,=TxQueue
  766 0000032C B672    putchar_l
                               CPSID            I
  767 0000032E F7FF FFFE       BL               Enqueue
  768 00000332 B662            CPSIE            I
  769 00000334 D2FA            BCS              putchar_l
  770 00000336         ; Enable the Tx interrupt
  771 00000336 484F            LDR              R0,=UART0_BASE
  772 00000338 21AC            MOVS             R1,#UART0_C2_TI_RI
  773 0000033A 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  774 0000033C BD03            POP              {R0,R1,PC}
  775 0000033E                 ENDP
  776 0000033E         
  777 0000033E         ; GetChar will real a character from the terminal
  778 0000033E         ; Subroutines used: Dequeue
  779 0000033E         ; Input: None
  780 0000033E         ; Output; R0 (character read from terminal)
  781 0000033E         ; Register modification list: R1-R3
  782 0000033E         GetChar PROC             {R1-R12}
  783 0000033E B502            PUSH             {R1,LR}
  784 00000340 494A            LDR              R1,=RxQueue
  785 00000342 B672    getchar_l
                               CPSID            I
  786 00000344 F7FF FFFE       BL               Dequeue
  787 00000348 B662            CPSIE            I
  788 0000034A D2FA            BCS              getchar_l
  789 0000034C BD02            POP              {R1,PC}
  790 0000034E                 ENDP
  791 0000034E         
  792 0000034E         
  793 0000034E         ; UART0_ISR will handler the UART0 interrupt
  794 0000034E         ; when data is ready to recieved/transmitted
  795 0000034E         ; Subroutines used: Enqueue, Dequeue
  796 0000034E         ; Input: None
  797 0000034E         ; Output: None
  798 0000034E         ; Reigster modification: None
  799 0000034E         UART0_ISR
                               PROC             {R0-R12}
  800 0000034E B500            PUSH             {LR}
  801 00000350 B672            CPSID            I           ; Don't interrupt i
                                                            n the middle of thi
                                                            s one
  802 00000352 4948            LDR              R1,=UART0_BASE
  803 00000354 2280            MOVS             R2,#UART0_C2_TIE_MASK
  804 00000356 78CB            LDRB             R3,[R1,#UART0_C2_OFFSET]
  805 00000358 421A            TST              R2,R3       ; If TIE = 1
  806 0000035A D00D            BEQ              check_Rx
  807 0000035C         
  808 0000035C         ; Check if there if the transmit



ARM Macro Assembler    Page 19 Program Title for Listing Header Goes Here


  809 0000035C         ; register is empty
  810 0000035C 2280            MOVS             R2,#UART0_S1_TDRE_MASK
  811 0000035E 790B            LDRB             R3,[R1,#UART0_S1_OFFSET]
  812 00000360 421A            TST              R2,R3
  813 00000362 D009            BEQ              check_Rx    ; Tx is not the sou
                                                            rce
  814 00000364         ; Get the next character from the Tx buffer
  815 00000364 4940            LDR              R1,=TxQueue
  816 00000366 F7FF FFFE       BL               Dequeue
  817 0000036A D202            BCS              disable_tx
  818 0000036C         ; Dequeue successful, write it to
  819 0000036C         ; the data register
  820 0000036C 4941            LDR              R1,=UART0_BASE
  821 0000036E 71C8            STRB             R0,[R1,#UART0_D_OFFSET]
  822 00000370 E002            B                check_Rx
  823 00000372         disable_tx                           ; No data to send, 
                                                            disable this interr
                                                            upt so we
  824 00000372         ; don't cause an infinite loop
  825 00000372         ; Disable Tx interrupt
  826 00000372 4940            LDR              R1,=UART0_BASE
  827 00000374 222C            MOVS             R2,#UART0_C2_T_RI
  828 00000376 70CA            STRB             R2,[R1,#UART0_C2_OFFSET]
  829 00000378 2220    check_Rx
                               MOVS             R2,#UART0_S1_RDRF_MASK
  830 0000037A 790B            LDRB             R3,[R1,#UART0_S1_OFFSET]
  831 0000037C 421A            TST              R2,R3
  832 0000037E D003            BEQ              uart0_isr_done
  833 00000380         
  834 00000380 79C8            LDRB             R0,[R1,#UART0_D_OFFSET]
  835 00000382 493A            LDR              R1,=RxQueue
  836 00000384 F7FF FFFE       BL               Enqueue     ; Put R0 in the RxQ
                                                            ueue
  837 00000388 B662    uart0_isr_done
                               CPSIE            I
  838 0000038A BD00            POP{PC}
  839 0000038C                 ENDP
  840 0000038C         
  841 0000038C         ; Print a NULL terminated string
  842 0000038C         ; SUBROUTINES USED
  843 0000038C         ;   - PutChar (Print each character)
  844 0000038C         ; PARAMS
  845 0000038C         ;   INPUT R0: pointer to the target string (word address
                       )
  846 0000038C         ;   INPUT R1: size of the string buffer so that to not o
                       verflow (unsigned word value)
  847 0000038C         ;   OUTPUT  : NONE
  848 0000038C         PutStringSB
                               PROC             {R0-R12}
  849 0000038C B51F            PUSH             {R0-R4,LR}
  850 0000038E         ; put_string_sb(char* r0, size_t r1)
  851 0000038E         ;   iter = r0
  852 0000038E         ;   while (*iter && iter - r0 < r1 - 1)
  853 0000038E         ;       printf("%c", *iter)
  854 0000038E         ;       iter++
  855 0000038E 0002            MOVS             R2,R0       ; iter = r0
  856 00000390 0004            MOVS             R4,R0       ; start = r0 (r0 ne
                                                            eds to be used for 
                                                            printing)



ARM Macro Assembler    Page 20 Program Title for Listing Header Goes Here


  857 00000392 1E49            SUBS             R1,R1,#1
  858 00000394         
  859 00000394 7813    putwhile
                               LDRB             R3,[R2,#0]  ; r3 = *iter
  860 00000396 2B00            CMP              R3,#0       ; if (!*r3) break
  861 00000398 D007            BEQ              putdone
  862 0000039A 1B13            SUBS             R3,R2,R4
  863 0000039C 428B            CMP              R3,R1       ; if (iter - start 
                                                            >= r1 - 1) break
  864 0000039E DA04            BGE              putdone
  865 000003A0 7810            LDRB             R0,[R2,#0]  ; r0 = *iter
  866 000003A2 F7FF FFFE       BL               PutChar     ; printf("%c", *ite
                                                            r);
  867 000003A6 1C52            ADDS             R2,R2,#1    ; iter++
  868 000003A8 E7F4            B                putwhile
  869 000003AA BD1F    putdone POP              {R0-R4,PC}
  870 000003AC         
  871 000003AC                 ENDP
  872 000003AC         
  873 000003AC         ; Initialize the UART0 serial polling with
  874 000003AC         ; 8 databits, no parity, one stop bit
  875 000003AC         ; Subroutines used: InitQueue
  876 000003AC         ; Input: None
  877 000003AC         ; Output: None
  878 000003AC         ; Register modification: R0-R2
  879 000003AC         Init_UART0_IRQ
                               PROC             {R3-R12}
  880 000003AC B507            PUSH             {R0-R2,LR}
  881 000003AE         ; Select/configure UART0 sources
  882 000003AE 04000000 
                       SIM_SOPT2_UART0SRC_MCGFLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
  883 000003AE         ; Set the UART0 clock to 48 MHz
  884 000003AE 4835            LDR              R0,=SIM_SOPT2
  885 000003B0 4935            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  886 000003B2 6802            LDR              R2,[R0,#0]  ;current SIM_SOPT2v
                                                            alue
  887 000003B4 438A            BICS             R2,R2,R1    ;only UART0SRCbits 
                                                            cleared
  888 000003B6 4935            LDR              R1,=SIM_SOPT2_UART0SRC_MCGFLLCL
K
  889 000003B8 430A            ORRS             R2,R2,R1    ;only UART0 bits ch
                                                            anged
  890 000003BA 6002            STR              R2,[R0,#0]  ;update SIM_SOPT2
  891 000003BC         
  892 000003BC         ; Set SIM_SOPT5 for UART0 External
  893 000003BC 00010005 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR: S
IM_SOPT5_UART0RXSRC_MASK :OR: SIM_SOPT5_UART0TXSRC_MASK)
  894 000003BC 4834            LDR              R0,=SIM_SOPT5
  895 000003BE 4935            LDR              R1,=SIM_SOPT5_UART0_EXTERN_MASK
_CLEAR
  896 000003C0 6802            LDR              R2,[R0,#0]  ;current SIM_SOPT5v
                                                            alue
  897 000003C2 438A            BICS             R2,R2,R1    ;only UART0 bits cl
                                                            eared
  898 000003C4 6002            STR              R2,[R0,#0]  ;update SIM_SOPT5
  899 000003C6         



ARM Macro Assembler    Page 21 Program Title for Listing Header Goes Here


  900 000003C6         ; Enable clocks for UART0 and Port B
  901 000003C6         ; Enable UART0 clocks
  902 000003C6 4834            LDR              R0,=SIM_SCGC4
  903 000003C8 4934            LDR              R1,=SIM_SCGC4_UART0_MASK
  904 000003CA 6802            LDR              R2,[R0,#0]  ;current SIM_SCGC4v
                                                            alue
  905 000003CC 430A            ORRS             R2,R2,R1    ;only UART0bit set
  906 000003CE 6002            STR              R2,[R0,#0]  ;update SIM_SCGC4
  907 000003D0         
  908 000003D0         ; Set SIM_CGC5 for Port B Clock Enabled
  909 000003D0 4833            LDR              R0,=SIM_SCGC5
  910 000003D2 4932            LDR              R1,=SIM_SCGC5_PORTB_MASK
  911 000003D4 6802            LDR              R2,[R0,#0]  ;current SIM_SCGC5v
                                                            alue
  912 000003D6 430A            ORRS             R2,R2,R1    ;only PORTBbit set
  913 000003D8 6002            STR              R2,[R0,#0]  ;update SIM_SCGC5
  914 000003DA         
  915 000003DA         ; Select Port B mux pins to connect to UART0
  916 000003DA 01000200 
                       PORT_PCR_SET_PTB2_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR: PORT_PC
R_MUX_SELECT_2_MASK)
  917 000003DA 01000200 
                       PORT_PCR_SET_PTB1_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR: PORT_PC
R_MUX_SELECT_2_MASK)
  918 000003DA         
  919 000003DA 4832            LDR              R0,=PORTB_PCR2
  920 000003DC 4932            LDR              R1,=PORT_PCR_SET_PTB2_UART0_RX
  921 000003DE 6001            STR              R1,[R0,#0]  ;Port B pin 2 conne
                                                            cts to UART0 Rx
  922 000003E0 4832            LDR              R0,=PORTB_PCR1
  923 000003E2 4931            LDR              R1,=PORT_PCR_SET_PTB1_UART0_TX
  924 000003E4 6001            STR              R1,[R0,#0]  ;Port B pin 1 conne
                                                            cts to UART0 Tx
  925 000003E6         
  926 000003E6         ; Configure UART0 (register initialization)
  927 000003E6         ; Load base addr for UART0
  928 000003E6 4823            LDR              R0,=UART0_BASE
  929 000003E8         
  930 000003E8         ; Disable UART0
  931 000003E8 210C            MOVS             R1,#UART0_C2_T_R
  932 000003EA 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  933 000003EC 438A            BICS             R2,R2,R1
  934 000003EE 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  935 000003F0         
  936 000003F0         ; Set UART0 baud rate?BDH before BDL
  937 000003F0 2101            MOVS             R1,#UART0_BDH_9600
  938 000003F2 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  939 000003F4 2138            MOVS             R1,#UART0_BDL_9600
  940 000003F6 7041            STRB             R1,[R0,#UART0_BDL_OFFSET]
  941 000003F8         
  942 000003F8         ; Set UART0 character format for serial bit stream and c
                       lear flags
  943 000003F8 2100            MOVS             R1,#UART0_C1_8N1
  944 000003FA 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  945 000003FC 2100            MOVS             R1,#UART0_C3_NO_TXINV
  946 000003FE 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  947 00000400 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16



ARM Macro Assembler    Page 22 Program Title for Listing Header Goes Here


  948 00000402 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  949 00000404 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  950 00000406 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  951 00000408 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  952 0000040A 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  953 0000040C 21C0            MOVS             R1,#UART0_S2_NO_RXINV_BRK10_NO_
LBKDETECT_CLEAR_FLAGS
  954 0000040E 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  955 00000410         
  956 00000410         ; Enable UART0
  957 00000410 210C            MOVS             R1,#UART0_C2_T_R
  958 00000412 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  959 00000414         
  960 00000414         ;Set UART0 IRQ priority
  961 00000414 4826            LDR              R0,=UART0_IPR
  962 00000416         ;LDR R1,=NVIC_IPR_UART0_MASK
  963 00000416 4A27            LDR              R2,=NVIC_IPR_UART0_PRI_3
  964 00000418 6803            LDR              R3,[R0,#0]
  965 0000041A         ;BICS R3,R3,R1
  966 0000041A 4313            ORRS             R3,R3,R2
  967 0000041C 6003            STR              R3,[R0,#0]
  968 0000041E         
  969 0000041E         ; Initialize the Rx and Tx queues
  970 0000041E 4814            LDR              R0,=RxBuffer
  971 00000420 4912            LDR              R1,=RxQueue
  972 00000422 2250            MOVS             R2,#X_BUF_SZ
  973 00000424 F7FF FFFE       BL               InitQueue
  974 00000428         
  975 00000428 4813            LDR              R0,=TxBuffer
  976 0000042A 490F            LDR              R1,=TxQueue
  977 0000042C 2250            MOVS             R2,#X_BUF_SZ
  978 0000042E F7FF FFFE       BL               InitQueue
  979 00000432         
  980 00000432         ;Clear any pending UART0 interrupts
  981 00000432 4825            LDR              R0,=NVIC_ICPR
  982 00000434 4925            LDR              R1,=NVIC_ICPR_UART0_MASK
  983 00000436 6001            STR              R1,[R0,#0]
  984 00000438         ;Unmask UART0 interrupts
  985 00000438 4825            LDR              R0,=NVIC_ISER
  986 0000043A 4924            LDR              R1,=NVIC_ISER_UART0_MASK
  987 0000043C 6001            STR              R1,[R0,#0]
  988 0000043E         
  989 0000043E BD07            POP              {R0-R2,PC}
  990 00000440                 ENDP
  991 00000440         
  992 00000440         ;>>>>>   end subroutine code <<<<<
  993 00000440                 ALIGN
  994 00000440         ;*******************************************************
                       *********
  995 00000440         ;Vector Table Mapped to Address 0 at Reset
  996 00000440         ;Linker requires __Vectors to be exported
  997 00000440 00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 



ARM Macro Assembler    Page 23 Program Title for Listing Header Goes Here


              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              4006A000 
              00000000 
              00000000 
              00000000 
              40048004 
              0C000000 
              04000000 
              40048010 
              00010005 
              40048034 
              00000400 
              40048038 
              4004A008 
              01000200 
              4004A004 
              E000E40C 
              000000C0 
              00000000 
              00000000 
              00000000 
              00000000 
              E000E280 
              00001000 
              E000E100         AREA             RESET, DATA, READONLY
  998 00000000                 EXPORT           __Vectors
  999 00000000                 EXPORT           __Vectors_End
 1000 00000000                 EXPORT           __Vectors_Size
 1001 00000000                 IMPORT           __initial_sp
 1002 00000000                 IMPORT           Dummy_Handler
 1003 00000000                 IMPORT           HardFault_Handler
 1004 00000000         __Vectors
 1005 00000000         ;ARM core vectors
 1006 00000000 00000000        DCD              __initial_sp ;00:end of stack
 1007 00000004 00000000        DCD              Reset_Handler ;01:reset vector
 1008 00000008 00000000        DCD              Dummy_Handler ;02:NMI
 1009 0000000C 00000000        DCD              HardFault_Handler 
                                                            ;03:hard fault
 1010 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
 1011 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
 1012 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)
 1013 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
 1014 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
 1015 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
 1016 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
 1017 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (super
                                                            visor call)
 1018 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
 1019 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)
 1020 00000038 00000000        DCD              Dummy_Handler ;14:PendSV (Penda
                                                            bleSrvReq)
 1021 0000003C         ;   pendable request 
 1022 0000003C         ;   for system service)
 1023 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (syst
                                                            em tick timer)



ARM Macro Assembler    Page 24 Program Title for Listing Header Goes Here


 1024 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0
                                                             transfer 
 1025 00000044         ;   complete/error
 1026 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1
                                                             transfer
 1027 00000048         ;   complete/error
 1028 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2
                                                             transfer
 1029 0000004C         ;   complete/error
 1030 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3
                                                             transfer
 1031 00000050         ;   complete/error
 1032 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
 1033 00000054 00000000        DCD              Dummy_Handler ;21:FTFA command 
                                                            complete/
 1034 00000058         ;   read collision
 1035 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage d
                                                            etect;
 1036 0000005C         ;   low-voltage warning
 1037 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage w
                                                            akeup
 1038 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
 1039 00000064 00000000        DCD              Dummy_Handler ;25:(reserved)
 1040 00000068 00000000        DCD              Dummy_Handler ;26:SPI0
 1041 0000006C 00000000        DCD              Dummy_Handler ;27:(reserved)
 1042 00000070 00000000        DCD              UART0_ISR   ;28:UART0 (status; 
                                                            error)
 1043 00000074 00000000        DCD              Dummy_Handler ;29:(reserved)
 1044 00000078 00000000        DCD              Dummy_Handler ;30:(reserved)
 1045 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
 1046 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
 1047 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
 1048 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
 1049 0000008C 00000000        DCD              Dummy_Handler ;35:(reserved)
 1050 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
 1051 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
                                                            
 1052 00000098 00000000        DCD              Dummy_Handler ;38:PIT
 1053 0000009C 00000000        DCD              Dummy_Handler ;39:(reserved)
 1054 000000A0 00000000        DCD              Dummy_Handler ;40:(reserved)
 1055 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
 1056 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
 1057 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
 1058 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
 1059 000000B4 00000000        DCD              Dummy_Handler ;45:(reserved)
 1060 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA
 1061 000000BC 00000000        DCD              Dummy_Handler ;47:PORTB
 1062 000000C0         __Vectors_End
 1063 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors
 1064 000000C0                 ALIGN
 1065 000000C0         ;*******************************************************
                       *********
 1066 000000C0         ;Constants
 1067 000000C0                 AREA             MyConst,DATA,READONLY
 1068 00000000         ;>>>>> begin constants here <<<<<
 1069 00000000 54 79 70 
              65 20 61 



ARM Macro Assembler    Page 25 Program Title for Listing Header Goes Here


              20 71 75 
              65 75 65 
              20 63 6F 
              6D 6D 61 
              6E 64 20 
              28 44 2C 
              45 2C 48 
              2C 50 2C 
              53 29 3A 
              00       prompt  DCB              "Type a queue command (D,E,H,P,
S):\0"
 1070 00000022 43 68 61 
              72 61 63 
              74 65 72 
              20 74 6F 
              20 65 6E 
              71 75 65 
              75 65 3A 
              00       prompt_en
                               DCB              "Character to enqueue:\0"
 1071 00000038 3A 09 49 
              6E 3D 30 
              78 25 78 
              20 20 4F 
              75 74 3D 
              30 78 25 
              78 20 20 
              4E 75 6D 
              3D 25 62 
              0D 0A 00 status  DCB              ":\tIn=0x%x  Out=0x%x  Num=%b\r
\n\0"
 1072 00000056 53 74 61 
              74 75 73 
              00       status_s
                               DCB              "Status\0"
 1073 0000005D 53 75 63 
              63 65 73 
              73 00    success DCB              "Success\0"
 1074 00000065 46 61 69 
              6C 75 72 
              65 00    failure DCB              "Failure\0"
 1075 0000006D 0D 0A 00 
                       newline DCB              "\r\n\0"
 1076 00000070 0D 0A 0D 
              0A 49 6E 
              76 61 6C 
              69 64 20 
              66 6F 72 
              6D 61 74 
              20 73 74 
              72 69 6E 
              67 20 27 
              25 73 27 
              0D 0A 00 invalid DCB              "\r\n\r\nInvalid format string 
'%s'\r\n\0"
 1077 00000091 49 6E 76 
              61 6C 69 
              64 20 63 
              6F 6D 6D 



ARM Macro Assembler    Page 26 Program Title for Listing Header Goes Here


              61 6E 64 
              20 27 25 
              63 27 0D 
              0A 00    invalid_in
                               DCB              "Invalid command '%c'\r\n\0"
 1078 000000A8 44 20 28 
              64 65 71 
              75 65 75 
              65 29 2C 
              20 45 20 
              28 65 6E 
              71 75 65 
              75 65 29 
              2C 20 48 
              20 28 68 
              65 6C 70 
              29 2C 20 
              50 20 28 
              70 72 69 
              6E 74 29 
              2C 20 53 
              20 28 73 
              74 61 74 
              75 73 29 
              0D 0A 00 help    DCB              "D (dequeue), E (enqueue), H (h
elp), P (print), S (status)\r\n\0"
 1079 000000E4 54 65 73 
              74 20 73 
              74 72 69 
              6E 67 20 
              25 6A 64 
              73 6F 6B 
              61 00    test_invalid_printf
                               DCB              "Test string %jdsoka\0" ; Just 
                                                            used to test the pr
                                                            intf() function
 1080 000000F8         ;>>>>>   end constants here <<<<<
 1081 000000F8                 ALIGN
 1082 000000F8         ;*******************************************************
                       *********
 1083 000000F8         ;Variables
 1084 000000F8                 AREA             MyData,DATA,READWRITE
 1085 00000000         ;>>>>> begin variables here <<<<<
 1086 00000000 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 queue   SPACE            Q_REC_SZ
 1087 00000012 00 00           ALIGN
 1088 00000014 00 00 00 
              00       buffer  SPACE            Q_BUF_SZ
 1089 00000018                 ALIGN
 1090 00000018 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 RxQueue SPACE            Q_REC_SZ



ARM Macro Assembler    Page 27 Program Title for Listing Header Goes Here


 1091 0000002A 00 00           ALIGN
 1092 0000002C 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 TxQueue SPACE            Q_REC_SZ
 1093 0000003E 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    RxBuffer
                               SPACE            X_BUF_SZ
 1094 0000008E 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 28 Program Title for Listing Header Goes Here


              00 00 00 
              00 00 00 
              00 00    TxBuffer
                               SPACE            X_BUF_SZ
 1095 000000DE 00 00           ALIGN
 1096 000000E0 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    printf_static
                               SPACE            20          ; Internal memory u
                                                            sed by printf
 1097 000000F4         ;>>>>>   end variables here <<<<<
 1098 000000F4                 ALIGN
 1099 000000F4                 END
Command Line: --debug --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --
depend=.\objects\exercise09.d -o.\objects\exercise09.o -I"C:\Users\Andrei Tumba
r\AppData\Local\Arm\Packs\Keil\Kinetis_KLxx_DFP\1.14.0\Device\Include" -IC:\Kei
l_v5\ARM\CMSIS\Include --predefine="__EVAL SETA 1" --predefine="__UVISION_VERSI
ON SETA 531" --predefine="MKL05Z32xxx4 SETA 1" --list=.\listings\exercise09.lst
 Exercise09.s
